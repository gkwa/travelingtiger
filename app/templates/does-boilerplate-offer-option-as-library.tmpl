{{define "does-boilerplate-offer-option-as-library"}}
I would like to make use of Gruntwork's boilerplate app as a golang library.

I am aware that `boilerplate` is offered as a binary to download, but instead of wrapping golang `os.system` around commandline call to the boilerplate binary, I want to include it into my golang app.

I've included the boilerplate source code within `<code/>` block here.

```
<code>
{{template "code" .}}
</code>
```
{{end}}

{{define "code"}}
-- .gon_amd64.hcl --
# See https://github.com/gruntwork-io/terraform-aws-ci/blob/main/modules/sign-binary-helpers/
# for further instructions on how to sign the binary + submitting for notarization.

source = ["./bin/boilerplate_darwin_amd64"]

bundle_id = "io.gruntwork.app.boilerplate"

apple_id {
  username = "machine.apple@gruntwork.io"
}

sign {
  application_identity = "Developer ID Application: Gruntwork, Inc."
}

zip {
  output_path = "boilerplate_darwin_amd64.zip"
}
-- .gon_arm64.hcl --
# See https://github.com/gruntwork-io/terraform-aws-ci/blob/main/modules/sign-binary-helpers/
# for further instructions on how to sign the binary + submitting for notarization.

source = ["./bin/boilerplate_darwin_arm64"]

bundle_id = "io.gruntwork.app.boilerplate"

apple_id {
  username = "machine.apple@gruntwork.io"
}

sign {
  application_identity = "Developer ID Application: Gruntwork, Inc."
}

zip {
  output_path = "boilerplate_darwin_arm64.zip"
}
-- cli/boilerplate_cli.go --
package cli

import (
	"fmt"

	"github.com/gruntwork-io/go-commons/entrypoint"
	"github.com/gruntwork-io/go-commons/version"
	"github.com/urfave/cli/v2"

	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/templates"
	"github.com/gruntwork-io/boilerplate/variables"
)

const customHelpText = `Usage: {{`{{`}}.UsageText}}

A tool for generating files and folders (\"boilerplate\") from a set of templates. Examples:

Generate a project in ~/output from the templates in ~/templates:

    boilerplate --template-url ~/templates --output-folder ~/output

Generate a project in ~/output from the templates in ~/templates, using variables passed in via the command line:

    boilerplate --template-url ~/templates --output-folder ~/output --var "Title=Boilerplate" --var "ShowLogo=false"

Generate a project in ~/output from the templates in ~/templates, using variables read from a file:

    boilerplate --template-url ~/templates --output-folder ~/output --var-file vars.yml

Generate a project in ~/output from the templates in this repo's include example dir, using variables read from a file:

	boilerplate --template-url "git@github.com:gruntwork-io/boilerplate.git//examples/for-learning-and-testing/include?ref=main" --output-folder ~/output --var-file vars.yml


Options:

   {{`{{`}}range .VisibleFlags}}{{`{{`}}.}}
   {{`{{`}}end}}`

func CreateBoilerplateCli() *cli.App {
	cli.HelpPrinter = entrypoint.WrappedHelpPrinter
	cli.AppHelpTemplate = customHelpText
	app := cli.NewApp()
	entrypoint.HelpTextLineWidth = 120

	app.Name = "boilerplate"
	app.Authors = []*cli.Author{
		{
			Name:  "Gruntwork",
			Email: "www.gruntwork.io",
		},
	}
	app.UsageText = "boilerplate [OPTIONS]"
	app.Version = version.GetVersion()
	app.Action = runApp

	app.Flags = []cli.Flag{
		&cli.StringFlag{
			Name:  options.OptTemplateUrl,
			Usage: "Generate the project from the templates in `URL`. This can be a local path, or a go-getter compatible URL for remote templates (e.g., `git@github.com:gruntwork-io/boilerplate.git//examples/for-learning-and-testing/include?ref=main`).",
		},
		&cli.StringFlag{
			Name:  options.OptOutputFolder,
			Usage: "Create the output files and folders in `FOLDER`.",
		},
		&cli.BoolFlag{
			Name:  options.OptNonInteractive,
			Usage: fmt.Sprintf("Do not prompt for input variables. All variables must be set via --%s and --%s options instead.", options.OptVar, options.OptVarFile),
		},
		&cli.StringSliceFlag{
			Name:  options.OptVar,
			Usage: "Use `NAME=VALUE` to set variable NAME to VALUE. May be specified more than once.",
		},
		&cli.StringSliceFlag{
			Name:  options.OptVarFile,
			Usage: "Load variable values from the YAML file `FILE`. May be specified more than once.",
		},
		&cli.StringFlag{
			Name:  options.OptMissingKeyAction,
			Usage: fmt.Sprintf("What `ACTION` to take if a template looks up a variable that is not defined. Must be one of: %s. Default: %s.", options.AllMissingKeyActions, options.DefaultMissingKeyAction),
		},
		&cli.StringFlag{
			Name:  options.OptMissingConfigAction,
			Usage: fmt.Sprintf("What `ACTION` to take if a the template folder does not contain a boilerplate.yml file. Must be one of: %s. Default: %s.", options.AllMissingConfigActions, options.DefaultMissingConfigAction),
		},
		&cli.BoolFlag{
			Name:  options.OptDisableHooks,
			Usage: "If this flag is set, no hooks will execute.",
		},
		&cli.BoolFlag{
			Name:  options.OptDisableShell,
			Usage: "If this flag is set, no shell helpers will execute. They will instead return the text 'replace-me'.",
		},
		&cli.BoolFlag{
			Name:  options.OptDisableDependencyPrompt,
			Usage: fmt.Sprintf("Do not prompt for confirmation to include dependencies. Has the same effect as --%s, without disabling variable prompts.", options.OptNonInteractive),
		},
	}

	// We pass JSON/YAML content to various CLI flags, such as --var, and this JSON/YAML content may contain commas or
	// other separators urfave/cli would treat as a slice separator, and would therefore break the value into multiple
	// parts in the middle of the JSON/YAML, which is not what we want. So here, we disable the slice separator to
	// avoid that issue. This means you have to pass --var multiple times to get multiple values, which is what we
	// want anyway. See https://github.com/urfave/cli/issues/1134 for more details.
	app.DisableSliceFlagSeparator = true

	return app

}

// When you run the CLI, this is the action function that gets called
func runApp(cliContext *cli.Context) error {
	if !cliContext.Args().Present() && cliContext.NumFlags() == 0 {
		return cli.ShowAppHelp(cliContext)
	}

	opts, err := options.ParseOptions(cliContext)
	if err != nil {
		return err
	}

	// The root boilerplate.yml is not itself a dependency, so we pass an empty Dependency.
	emptyDep := variables.Dependency{}

	return templates.ProcessTemplate(opts, opts, emptyDep)
}
-- config/config.go --
package config

import (
	"fmt"
	"io/ioutil"
	"net/url"
	"path"
	"strings"

	"github.com/gruntwork-io/go-commons/version"
	goversion "github.com/hashicorp/go-version"
	"gopkg.in/yaml.v2"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
)

const BOILERPLATE_CONFIG_FILE = "boilerplate.yml"

// The contents of a boilerplate.yml config file
type BoilerplateConfig struct {
	RequiredVersion *string
	Variables       []variables.Variable
	Dependencies    []variables.Dependency
	Hooks           variables.Hooks
	Partials        []string
	SkipFiles       []variables.SkipFile
	Engines         []variables.Engine
}

// GetVariablesMap returns a map that maps variable names to the variable config.
func (config *BoilerplateConfig) GetVariablesMap() map[string]variables.Variable {
	out := make(map[string]variables.Variable)
	for _, variable := range config.Variables {
		out[variable.Name()] = variable
	}
	return out
}

// Implement the go-yaml unmarshal interface for BoilerplateConfig. We can't let go-yaml handle this itself because:
//
// 1. Variable is an interface
// 2. We need to provide Defaults for optional fields, such as "type"
// 3. We want to validate the variable as part of the unmarshalling process so we never have invalid Variable or
//    Dependency classes floating around
func (config *BoilerplateConfig) UnmarshalYAML(unmarshal func(interface{}) error) error {
	var fields map[string]interface{}
	if err := unmarshal(&fields); err != nil {
		return err
	}

	requiredVersion, err := variables.UnmarshalString(fields, "required_version", false)
	if err != nil {
		return err
	}

	vars, err := variables.UnmarshalVariablesFromBoilerplateConfigYaml(fields)
	if err != nil {
		return err
	}

	deps, err := variables.UnmarshalDependenciesFromBoilerplateConfigYaml(fields)
	if err != nil {
		return err
	}

	hooks, err := variables.UnmarshalHooksFromBoilerplateConfigYaml(fields)
	if err != nil {
		return err
	}

	partials, err := variables.UnmarshalListOfStrings(fields, "partials")
	if err != nil {
		return err
	}

	skipFiles, err := variables.UnmarshalSkipFilesFromBoilerplateConfigYaml(fields)
	if err != nil {
		return err
	}

	engines, err := variables.UnmarshalEnginesFromBoilerplateConfigYaml(fields)
	if err != nil {
		return err
	}

	*config = BoilerplateConfig{
		RequiredVersion: requiredVersion,
		Variables:       vars,
		Dependencies:    deps,
		Hooks:           hooks,
		Partials:        partials,
		SkipFiles:       skipFiles,
		Engines:         engines,
	}
	return nil
}

// Implement the go-yaml marshaler interface so that the config can be marshaled into yaml. We use a custom marshaler
// instead of defining the fields as tags so that we skip the attributes that are empty.
func (config *BoilerplateConfig) MarshalYAML() (interface{}, error) {
	configYml := map[string]interface{}{}
	if len(config.Variables) > 0 {
		// Due to go type system, we can only pass through []interface{}, even though []Variable is technically
		// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
		// function.
		interfaceList := []interface{}{}
		for _, variable := range config.Variables {
			interfaceList = append(interfaceList, variable)
		}
		varsYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		configYml["variables"] = varsYml
	}
	if len(config.Dependencies) > 0 {
		// Due to go type system, we can only pass through []interface{}, even though []Dependency is technically
		// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
		// function.
		interfaceList := []interface{}{}
		for _, dep := range config.Dependencies {
			interfaceList = append(interfaceList, dep)
		}
		depsYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		configYml["dependencies"] = depsYml
	}
	if len(config.Hooks.BeforeHooks) > 0 || len(config.Hooks.AfterHooks) > 0 {
		hooksYml, err := config.Hooks.MarshalYAML()
		if err != nil {
			return nil, err
		}
		configYml["hooks"] = hooksYml
	}
	if len(config.Partials) > 0 {
		configYml["partials"] = config.Partials
	}
	if len(config.SkipFiles) > 0 {
		// Due to go type system, we can only pass through []interface{}, even though []SkipFile is technically
		// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
		// function.
		interfaceList := []interface{}{}
		for _, skipFile := range config.SkipFiles {
			interfaceList = append(interfaceList, skipFile)
		}
		skipFilesYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		configYml["skip_files"] = skipFilesYml
	}
	if len(config.Engines) > 0 {
		// Due to go type system, we can only pass through []interface{}, even though []Engine is technically
		// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
		// function.
		interfaceList := []interface{}{}
		for _, engine := range config.Engines {
			interfaceList = append(interfaceList, engine)
		}
		enginesYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		configYml["engines"] = enginesYml
	}
	return configYml, nil
}

// Load the boilerplate.yml config contents for the folder specified in the given options
func LoadBoilerplateConfig(opts *options.BoilerplateOptions) (*BoilerplateConfig, error) {
	configPath := BoilerplateConfigPath(opts.TemplateFolder)

	if util.PathExists(configPath) {
		util.Logger.Printf("Loading boilerplate config from %s", configPath)
		bytes, err := ioutil.ReadFile(configPath)
		if err != nil {
			return nil, errors.WithStackTrace(err)
		}

		return ParseBoilerplateConfig(bytes)
	} else if opts.OnMissingConfig == options.Ignore {
		util.Logger.Printf("Warning: boilerplate config file not found at %s. The %s flag is set, so ignoring. Note that no variables will be available while generating.", configPath, options.OptMissingConfigAction)
		return &BoilerplateConfig{}, nil
	} else {
		// If the template URL is similar to a git URL, surface in error message that there may be a misspelling/typo.
		return nil, errors.WithStackTrace(BoilerplateConfigNotFound(configPath))
	}
}

// Parse the given configContents as a boilerplate.yml config file
func ParseBoilerplateConfig(configContents []byte) (*BoilerplateConfig, error) {
	boilerplateConfig := &BoilerplateConfig{}

	if err := yaml.Unmarshal(configContents, boilerplateConfig); err != nil {
		return nil, errors.WithStackTrace(err)
	}

	converted, err := variables.ConvertYAMLToStringMap(boilerplateConfig)
	if err != nil {
		return boilerplateConfig, err
	}

	boilerplateConfig, ok := converted.(*BoilerplateConfig)
	if !ok {
		return nil, variables.YAMLConversionErr{Key: converted}
	}

	return boilerplateConfig, nil
}

// Return the default path for a boilerplate.yml config file in the given folder
func BoilerplateConfigPath(templateFolder string) string {
	return path.Join(templateFolder, BOILERPLATE_CONFIG_FILE)
}

// EnforceRequiredVersion enforces any required_version string that is configured on the boilerplate config by checking
// against the current version of the CLI.
func EnforceRequiredVersion(boilerplateConfig *BoilerplateConfig) error {
	// Base case: if required_version is not set, then there is no version to enforce.
	if boilerplateConfig == nil || boilerplateConfig.RequiredVersion == nil {
		return nil
	}
	constraint := *boilerplateConfig.RequiredVersion

	// Base case: if using a development version, then bypass required version check
	currentVersion := version.GetVersion()
	if currentVersion == "" {
		return nil
	}

	// At this point there is a valid version that needs to be checked against the constraint
	boilerplateVersion, err := goversion.NewVersion(currentVersion)
	if err != nil {
		return errors.WithStackTrace(err)
	}
	versionConstraint, err := goversion.NewConstraint(constraint)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	if !versionConstraint.Check(boilerplateVersion) {
		return errors.WithStackTrace(InvalidBoilerplateVersion{CurrentVersion: boilerplateVersion, VersionConstraints: versionConstraint})
	}
	return nil
}

// maybeGitURL uses heuristics to attempt to decide if the URL may be a github URL that is encoded incorrectly.
func maybeGitURL(templateURL string) bool {
	potentialGitURLs := []string{
		"github.com",
		"gitlab.com",
		"bitbucket.org",
	}
	for _, url := range potentialGitURLs {
		if strings.Contains(templateURL, url) {
			return true
		}
	}

	// If the URL can be parsed and any non-file URL part is parsed out, return that this may be a git URL.
	parsed, err := url.Parse(templateURL)
	if err != nil {
		return false
	}
	return parsed.Scheme != "" || parsed.Hostname() != "" || parsed.RawQuery != ""
}

// Custom error types

type BoilerplateConfigNotFound string

func (err BoilerplateConfigNotFound) Error() string {
	errMsg := fmt.Sprintf("Could not find %s in %s and the %s flag is set to %s", BOILERPLATE_CONFIG_FILE, string(err), options.OptMissingConfigAction, options.Exit)

	configPath := string(err)
	if maybeGitURL(configPath) {
		errMsg += ". Template URL looks like a git repo. Did you misspell the URL? Should be encoded as one of the following: `git::ssh://git@github.com/ORG/REPO`, `github.com/ORG/REPO`, `https://github.com/ORG/REPO`, or `git@github.com:ORG/REPO`."
	}

	return errMsg
}

type InvalidBoilerplateVersion struct {
	CurrentVersion     *goversion.Version
	VersionConstraints goversion.Constraints
}

func (err InvalidBoilerplateVersion) Error() string {
	return fmt.Sprintf("The currently installed version of Boilerplate (%s) is not compatible with the version constraint requiring (%s).", err.CurrentVersion.String(), err.VersionConstraints.String())
}
-- config/config_test.go --
package config

import (
	"bytes"
	"io/ioutil"
	"path"
	"path/filepath"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
	"gopkg.in/yaml.v2"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/variables"

	// NOTE: we use this library to format the yaml to a standard format that lexicographically sorts the dictionary
	// keys to make comparisons more robust. We should not however use it in the CLI itself because it does not make the
	// YAML more readable (it culls all whitespace).
	"github.com/stuart-warren/yamlfmt"
)

func TestParseBoilerplateConfigEmpty(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(""))
	expected := &BoilerplateConfig{}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

func TestParseBoilerplateConfigInvalid(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte("not-a-valid-yaml-file"))

	assert.NotNil(t, err)

	unwrapped := errors.Unwrap(err)
	_, isYamlTypeError := unwrapped.(*yaml.TypeError)
	assert.True(t, isYamlTypeError, "Expected a YAML type error for an invalid yaml file but got %s: %v", reflect.TypeOf(unwrapped), unwrapped)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_EMPTY_VARIABLES_AND_DEPENDENCIES = `variables:
dependencies:
`

func TestParseBoilerplateConfigEmptyVariablesAndDependencies(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_EMPTY_VARIABLES_AND_DEPENDENCIES))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_MINIMAL = `variables:
  - name: foo
`

func TestParseBoilerplateConfigOneVariableMinimal(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_MINIMAL))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("foo"),
		},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_FULL = `variables:
  - name: foo
    description: example description
    type: string
    default: default
`

func TestParseBoilerplateConfigOneVariableFull(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_FULL))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("foo").WithDescription("example description").WithDefault("default"),
		},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_MISSING_NAME = `variables:
  - description: example description
    default: default
`

func TestParseBoilerplateConfigOneVariableMissingName(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_MISSING_NAME))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.RequiredFieldMissing("name")), "Expected a RequiredFieldMissing error but got %s: %v", reflect.TypeOf(errors.Unwrap(err)), err)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_INVALID_TYPE = `variables:
  - name: foo
    type: foo
`

func TestParseBoilerplateConfigOneVariableInvalidType(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_INVALID_TYPE))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.InvalidBoilerplateType("foo")), "Expected a InvalidBoilerplateType error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_INVALID_TYPE_FOR_NAME_FIELD = `variables:
  - name:
      - foo
      - bar
`

func TestParseBoilerplateConfigInvalidTypeForNameField(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_INVALID_TYPE_FOR_NAME_FIELD))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.InvalidTypeForField{FieldName: "name", ExpectedType: "string", ActualType: reflect.TypeOf([]interface{}{})}), "Expected a InvalidTypeForField error but got %s: %v", reflect.TypeOf(errors.Unwrap(err)), err)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_ENUM_NO_OPTIONS = `variables:
  - name: foo
    type: enum
`

func TestParseBoilerplateConfigOneVariableEnumNoOptions(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_ENUM_NO_OPTIONS))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.OptionsMissing("foo")), "Expected a VariableMissingOptions error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_ENUM_OPTIONS_WRONG_TYPE = `variables:
  - name: foo
    type: enum
    options: foo
`

func TestParseBoilerplateConfigOneVariableEnumWrongType(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_ENUM_OPTIONS_WRONG_TYPE))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.InvalidTypeForField{FieldName: "options", ExpectedType: "List", ActualType: reflect.TypeOf("string"), Context: "foo"}), "Expected a InvalidTypeForField error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_VARIABLE_OPTIONS_FOR_NON_ENUM = `variables:
  - name: foo
    options:
      - foo
      - bar
`

func TestParseBoilerplateConfigOneVariableOptionsForNonEnum(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_VARIABLE_OPTIONS_FOR_NON_ENUM))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.OptionsCanOnlyBeUsedWithEnum{Context: "foo", Type: variables.String}), "Expected a OptionsCanOnlyBeUsedWithEnum error but got %v", err)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_MULTIPLE_VARIABLES = `variables:
  - name: foo

  - name: bar
    description: example description

  - name: baz
    description: example description
    type: int
    default: 3

  - name: dep1.baz
    description: another example description
    type: bool
    default: true
`

func TestParseBoilerplateConfigMultipleVariables(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_MULTIPLE_VARIABLES))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("foo"),
			variables.NewStringVariable("bar").WithDescription("example description"),
			variables.NewIntVariable("baz").WithDescription("example description").WithDefault(3),
			variables.NewBoolVariable("dep1.baz").WithDescription("another example description").WithDefault(true),
		},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ALL_TYPES = `variables:
  - name: var1
    default: foo

  - name: var2
    type: string
    default: foo

  - name: var3
    type: int
    default: 5

  - name: var4
    type: float
    default: 5.5

  - name: var5
    type: bool
    default: true

  - name: var6
    type: list
    default:
      - foo
      - bar
      - baz

  - name: var7
    type: map
    default:
      key1: value1
      key2: value2
      key3: value3

  - name: var8
    type: enum
    options:
      - foo
      - bar
      - baz
    default: bar
`

func TestParseBoilerplateConfigAllTypes(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ALL_TYPES))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("var1").WithDefault("foo"),
			variables.NewStringVariable("var2").WithDefault("foo"),
			variables.NewIntVariable("var3").WithDefault(5),
			variables.NewFloatVariable("var4").WithDefault(5.5),
			variables.NewBoolVariable("var5").WithDefault(true),
			variables.NewListVariable("var6").WithDefault([]interface{}{"foo", "bar", "baz"}),
			variables.NewMapVariable("var7").WithDefault(map[interface{}]interface{}{"key1": "value1", "key2": "value2", "key3": "value3"}),
			variables.NewEnumVariable("var8", []string{"foo", "bar", "baz"}).WithDefault("bar"),
		},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_DEPENDENCY = `dependencies:
  - name: dep1
    template-url: /template/folder1
    output-folder: /output/folder1
`

func TestParseBoilerplateConfigOneDependency(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_DEPENDENCY))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{},
		Dependencies: []variables.Dependency{
			{Name: "dep1", TemplateUrl: "/template/folder1", OutputFolder: "/output/folder1", DontInheritVariables: false, Variables: []variables.Variable{}},
		},
		Hooks: variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_MULTIPLE_DEPENDENCIES = `dependencies:
  - name: dep1
    template-url: /template/folder1
    output-folder: /output/folder1

  - name: dep2
    template-url: /template/folder2
    output-folder: /output/folder2
    dont-inherit-variables: true
    variables:
      - name: var1
        description: Enter var1
        default: foo

  - name: dep3
    template-url: /template/folder3
    output-folder: /output/folder3
    skip: "{{`{{`}} and .Foo .Bar }}"
`

func TestParseBoilerplateConfigMultipleDependencies(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_MULTIPLE_DEPENDENCIES))
	expected := &BoilerplateConfig{
		Variables: []variables.Variable{},
		Dependencies: []variables.Dependency{
			{
				Name:                 "dep1",
				TemplateUrl:          "/template/folder1",
				OutputFolder:         "/output/folder1",
				DontInheritVariables: false,
				Variables:            []variables.Variable{},
			},
			{
				Name:                 "dep2",
				TemplateUrl:          "/template/folder2",
				OutputFolder:         "/output/folder2",
				DontInheritVariables: true,
				Variables: []variables.Variable{
					variables.NewStringVariable("var1").WithDescription("Enter var1").WithDefault("foo"),
				},
			},
			{
				Name:                 "dep3",
				TemplateUrl:          "/template/folder3",
				OutputFolder:         "/output/folder3",
				DontInheritVariables: false,
				Variables:            []variables.Variable{},
				Skip:                 "{{`{{`}} and .Foo .Bar }}",
			},
		},
		Hooks: variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_DEPENDENCY_MISSING_NAME = `dependencies:
  - template-url: /template/folder1
    output-folder: /output/folder1
`

func TestParseBoilerplateConfigDependencyMissingName(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_DEPENDENCY_MISSING_NAME))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.RequiredFieldMissing("name")), "Expected a RequiredFieldMissing error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_DEPENDENCY_MISSING_TEMPLATE_FOLDER = `dependencies:
  - name: dep1
    output-folder: /output/folder1
`

func TestParseBoilerplateConfigDependencyMissingTemplateUrl(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_DEPENDENCY_MISSING_TEMPLATE_FOLDER))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.RequiredFieldMissing("template-url")), "Expected a RequiredFieldMissing error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_DEPENDENCY_MISSING_VARIABLE_NAME = `dependencies:
  - name: dep1
    template-url: /template/folder1
    output-folder: /output/folder1
    variables:
      - description: Enter foo
        default: foo
`

func TestParseBoilerplateConfigDependencyMissingVariableName(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_DEPENDENCY_MISSING_VARIABLE_NAME))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.RequiredFieldMissing("name")), "Expected a RequiredFieldMissing error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_DEPENDENCY_MISSING_OUTPUT_FOLDER = `dependencies:
  - name: dep1
    template-url: /template/folder1
    output-folder: /output/folder1

  - name: dep2
    template-url: /template/folder2
`

func TestParseBoilerplateConfigDependencyMissingOutputFolder(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_DEPENDENCY_MISSING_OUTPUT_FOLDER))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.RequiredFieldMissing("output-folder")), "Expected a RequiredFieldMissing error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_DEPENDENCY_DUPLICATE_NAMES = `dependencies:
  - name: dep1
    template-url: /template/folder1
    output-folder: /output/folder1

  - name: dep2
    template-url: /template/folder2
    output-folder: /output/folder2

  - name: dep1
    template-url: /template/folder3
    output-folder: /output/folder3
`

func TestParseBoilerplateConfigDependencyDuplicateNames(t *testing.T) {
	t.Parallel()

	_, err := ParseBoilerplateConfig([]byte(CONFIG_DEPENDENCY_DUPLICATE_NAMES))

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, variables.DuplicateDependencyName("dep1")), "Expected a DuplicateDependencyName error but got %s", reflect.TypeOf(errors.Unwrap(err)))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_EMPTY_HOOKS = `hooks:
`

func TestParseBoilerplateConfigEmptyHooks(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_EMPTY_HOOKS))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_EMPTY_BEFORE_AND_AFTER_HOOKS = `hooks:
   before:
   after:
`

func TestParseBoilerplateConfigEmptyBeforeAndAfterHooks(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_EMPTY_BEFORE_AND_AFTER_HOOKS))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_BEFORE_HOOK_NO_ARGS = `hooks:
   before:
     - command: foo
`

func TestParseBoilerplateConfigOneBeforeHookNoArgs(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_BEFORE_HOOK_NO_ARGS))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks: variables.Hooks{
			BeforeHooks: []variables.Hook{
				{Command: "foo"},
			},
		},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_ONE_AFTER_HOOK_WITH_ARGS = `hooks:
   after:
     - command: foo
       args:
         - bar
         - baz
       env:
         foo: bar
`

func TestParseBoilerplateConfigOneAfterHookWithArgs(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_ONE_AFTER_HOOK_WITH_ARGS))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks: variables.Hooks{
			AfterHooks: []variables.Hook{
				{Command: "foo", Args: []string{"bar", "baz"}, Env: map[string]string{"foo": "bar"}},
			},
		},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const CONFIG_MULTIPLE_HOOKS = `hooks:
   before:
     - command: echo
       args:
         - Hello World
       env:
         foo: bar
         baz: blah
       skip: "true"

     - command: run-some-script.sh
       args:
         - "{{`{{`}} .foo }}"
         - "{{`{{`}} .bar }}"

   after:
     - command: foo
       skip: "{{`{{`}} .baz }}"
     - command: bar
`

func TestParseBoilerplateConfigMultipleHooks(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(CONFIG_MULTIPLE_HOOKS))
	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks: variables.Hooks{
			BeforeHooks: []variables.Hook{
				{Command: "echo", Args: []string{"Hello World"}, Env: map[string]string{"foo": "bar", "baz": "blah"}, Skip: "true"},
				{Command: "run-some-script.sh", Args: []string{"{{`{{`}} .foo }}", "{{`{{`}} .bar }}"}},
			},
			AfterHooks: []variables.Hook{
				{Command: "foo", Skip: "{{`{{`}} .baz }}"},
				{Command: "bar"},
			},
		},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

func TestLoadBoilerplateConfigFullConfig(t *testing.T) {
	t.Parallel()

	actual, err := LoadBoilerplateConfig(&options.BoilerplateOptions{TemplateFolder: "../test-fixtures/config-test/full-config"})
	expected := &BoilerplateConfig{
		Partials: []string{"../templates/foo"},
		Variables: []variables.Variable{
			variables.NewStringVariable("foo"),
			variables.NewStringVariable("bar").WithDescription("example description"),
			variables.NewStringVariable("baz").WithDescription("example description").WithDefault("default"),
		},
		Dependencies: []variables.Dependency{
			{Name: "dep1", TemplateUrl: "/template/folder1", OutputFolder: "/output/folder1", DontInheritVariables: false, Variables: []variables.Variable{}},
			{Name: "dep2", TemplateUrl: "/template/folder2", OutputFolder: "/output/folder2", DontInheritVariables: true, Variables: []variables.Variable{
				variables.NewStringVariable("baz").WithDescription("example description").WithDefault("other-default"),
				variables.NewStringVariable("abc").WithDescription("example description").WithDefault("default"),
			}},
		},
		Hooks: variables.Hooks{
			BeforeHooks: []variables.Hook{
				{Command: "echo", Args: []string{"Hello World"}},
			},
			AfterHooks: []variables.Hook{
				{Command: "foo"},
				{Command: "bar"},
			},
		},
	}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

func TestLoadBoilerplateConfigNoConfig(t *testing.T) {
	t.Parallel()

	templateFolder := "../test-fixtures/config-test/no-config"
	_, err := LoadBoilerplateConfig(&options.BoilerplateOptions{TemplateFolder: templateFolder})
	expectedErr := BoilerplateConfigNotFound(path.Join(templateFolder, "boilerplate.yml"))

	assert.True(t, errors.IsError(err, expectedErr), "Expected error %v but got %v", expectedErr, err)
}

func TestLoadBoilerplateConfigNoConfigIgnore(t *testing.T) {
	t.Parallel()

	templateFolder := "../test-fixtures/config-test/no-config"
	actual, err := LoadBoilerplateConfig(&options.BoilerplateOptions{TemplateFolder: templateFolder, OnMissingConfig: options.Ignore})
	expected := &BoilerplateConfig{}

	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, expected, actual)
}

func TestLoadBoilerplateConfigInvalidConfig(t *testing.T) {
	t.Parallel()

	_, err := LoadBoilerplateConfig(&options.BoilerplateOptions{TemplateFolder: "../test-fixtures/config-test/invalid-config"})

	assert.NotNil(t, err)

	unwrapped := errors.Unwrap(err)
	_, isYamlTypeError := unwrapped.(*yaml.TypeError)
	assert.True(t, isYamlTypeError, "Expected a YAML type error for an invalid yaml file but got %s", reflect.TypeOf(unwrapped))
}

// YAML is whitespace sensitive, so we need to be careful that we don't introduce unnecessary indentation
const configWithSkipFiles = `skip_files:
  - path: "docs/README_ALWAYS_SKIP.md"
  - path: "docs/README_MAYBE_SKIP.md"
    if: "{{`{{`}} .MaybeSkip }}"
  - not_path: "docs/**/*"
    if: "{{`{{`}} .DocsOnly }}"
`

func TestParseBoilerplateConfigWithSkipFiles(t *testing.T) {
	t.Parallel()

	actual, err := ParseBoilerplateConfig([]byte(configWithSkipFiles))
	require.NoError(t, err)

	expected := &BoilerplateConfig{
		Variables:    []variables.Variable{},
		Dependencies: []variables.Dependency{},
		Hooks:        variables.Hooks{},
		SkipFiles: []variables.SkipFile{
			{Path: "docs/README_ALWAYS_SKIP.md", If: ""},
			{Path: "docs/README_MAYBE_SKIP.md", If: "{{`{{`}} .MaybeSkip }}"},
			{NotPath: "docs/**/*", If: "{{`{{`}} .DocsOnly }}"},
		},
	}
	assert.Equal(t, expected, actual)
}

func TestMarshalBoilerplateConfig(t *testing.T) {
	t.Parallel()

	marshalYamlTestExpectedBase := filepath.Join("..", "test-fixtures", "marshal-yaml-test")
	examplesBase := filepath.Join("..", "examples", "for-learning-and-testing")

	examplesToTest, err := ioutil.ReadDir(marshalYamlTestExpectedBase)
	require.NoError(t, err)

	for _, exampleFolder := range examplesToTest {
		exampleFolderName := exampleFolder.Name()

		t.Run(exampleFolderName, func(t *testing.T) {
			t.Parallel()

			configData, err := ioutil.ReadFile(filepath.Join(examplesBase, exampleFolderName, "boilerplate.yml"))
			require.NoError(t, err)
			config, err := ParseBoilerplateConfig(configData)
			require.NoError(t, err)
			actualYml, err := yaml.Marshal(config)
			require.NoError(t, err)
			expectedYml, err := ioutil.ReadFile(filepath.Join(marshalYamlTestExpectedBase, exampleFolderName, "expected.yml"))
			require.NoError(t, err)

			// Format the two yaml documents
			expectedYmlFormatted := formatYAMLBytes(t, expectedYml)
			actualYmlFormatted := formatYAMLBytes(t, actualYml)
			assert.Equal(t, string(expectedYmlFormatted), string(actualYmlFormatted))
		})
	}
}

func formatYAMLBytes(t *testing.T, ymlData []byte) []byte {
	ymlBuffer := bytes.NewBuffer(ymlData)
	formattedYml, err := yamlfmt.Format(ymlBuffer)
	require.NoError(t, err)
	return formattedYml
}
-- config/get_variables.go --
package config

import (
	"fmt"
	"log"
	"sort"

	"github.com/AlecAivazis/survey/v2"
	"github.com/AlecAivazis/survey/v2/terminal"
	validation "github.com/go-ozzo/ozzo-validation"
	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/render"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
	"github.com/hashicorp/go-multierror"
	"github.com/pterm/pterm"
)

const MaxReferenceDepth = 20

// Get a value for each of the variables specified in boilerplateConfig, other than those already in existingVariables.
// The value for a variable can come from the user (if the  non-interactive option isn't set), the default value in the
// config, or a command line option.
func GetVariables(opts *options.BoilerplateOptions, boilerplateConfig, rootBoilerplateConfig *BoilerplateConfig, thisDep variables.Dependency) (map[string]interface{}, error) {
	renderedVariables := map[string]interface{}{}

	// Add a variable for all variables contained in the root config file. This will allow Golang template users
	// to directly access these with an expression like "{{`{{`}} .BoilerplateConfigVars.foo.Default }}"
	rootConfigVars := rootBoilerplateConfig.GetVariablesMap()
	renderedVariables["BoilerplateConfigVars"] = rootConfigVars

	// Add a variable for all dependencies contained in the root config file. This will allow Golang template users
	// to directly access these with an expression like "{{`{{`}} .BoilerplateConfigDeps.foo.OutputFolder }}"
	rootConfigDeps := map[string]variables.Dependency{}
	for _, dep := range rootBoilerplateConfig.Dependencies {
		rootConfigDeps[dep.Name] = dep
	}
	renderedVariables["BoilerplateConfigDeps"] = rootConfigDeps

	// Add a variable for "the boilerplate template currently being processed".
	thisTemplateProps := map[string]interface{}{}
	thisTemplateProps["Config"] = boilerplateConfig
	thisTemplateProps["Options"] = opts
	thisTemplateProps["CurrentDep"] = thisDep
	renderedVariables["This"] = thisTemplateProps

	// The variables up to this point don't need any additional processing as they are builtin. User defined variables
	// can reference and use Go template syntax, so we pass them through a rendering pipeline to ensure they are
	// evaluated to values that can be used in the rest of the templates.
	variablesToRender := map[string]interface{}{}

	// Collect the variable values that have been passed in from the command line.
	for key, value := range opts.Vars {
		variablesToRender[key] = value
	}

	// Collect the variable values that are defined in the config and get the value.
	variablesInConfig := boilerplateConfig.GetVariablesMap()

	// Prior to prompting the user for the defined variable values, we sort the variables
	// by user-defined presentation order. Users may specify the order: value when defining
	// their variables in boilerplate.yml. This order value is an int, and it is used to
	// determine the relative ordering of the variables by key name
	// In essence, since Go maps do not preserve order for performance reasons, we need to
	// work around that and introduce a concept of use-defined ordering when prompting for
	// variables. We do this to provide a more coherent and easy to work with form filling
	// process for our Ref Arch customers

	// Create a slice of KeyOrderPairs, which we'll be able to sort according to order value
	keyAndOrderPairs := []KeyAndOrderPair{}

	// Pair the keys for each variable to its user-defined presentation order
	for key, variable := range variablesInConfig {
		kop := KeyAndOrderPair{
			Key:   key,
			Order: variable.Order(),
		}
		keyAndOrderPairs = append(keyAndOrderPairs, kop)
	}

	// Sort the KeyAndOrderPairs by their order value
	// N.B. this syntax of sort.Slice requires Go 1.18 or above!
	sort.Slice(keyAndOrderPairs[:], func(i, j int) bool {
		return keyAndOrderPairs[i].Order < keyAndOrderPairs[j].Order
	})

	// Now, instead of just iterating through the map keys naively,
	// iterate through the slice of KeyOrderPairs, which are sorted by order
	// which means that in each iteration of the loop, we can fetch the next variable
	// by looking up its key in the original config-provided variables map
	for _, keyOrderPair := range keyAndOrderPairs {
		variable := variablesInConfig[keyOrderPair.Key]
		unmarshalled, err := GetValueForVariable(variable, variablesInConfig, variablesToRender, opts, 0)
		if err != nil {
			return nil, err
		}
		variablesToRender[variable.Name()] = unmarshalled
	}

	// Pass all the user provided variables through a rendering pipeline to ensure they are evaluated down to
	// primitives.
	newlyRenderedVariables, err := render.RenderVariables(opts, variablesToRender, renderedVariables)
	if err != nil {
		return nil, err
	}

	// Convert all the rendered variables to match the type definition in the boilerplate config.
	for _, variable := range variablesInConfig {
		renderedValue := newlyRenderedVariables[variable.Name()]
		renderedValueWithType, err := variables.ConvertType(renderedValue, variable)
		if err != nil {
			return nil, err
		}
		renderedVariables[variable.Name()] = renderedValueWithType
	}

	return renderedVariables, nil
}

func GetValueForVariable(
	variable variables.Variable,
	variablesInConfig map[string]variables.Variable,
	valuesForPreviousVariables map[string]interface{},
	opts *options.BoilerplateOptions,
	referenceDepth int,
) (interface{}, error) {
	if referenceDepth > MaxReferenceDepth {
		return nil, errors.WithStackTrace(CyclicalReference{VariableName: variable.Name(), ReferenceName: variable.Reference()})
	}

	value, alreadyExists := valuesForPreviousVariables[variable.Name()]
	if alreadyExists {
		return value, nil
	}

	if variable.Reference() != "" {
		value, alreadyExists := valuesForPreviousVariables[variable.Reference()]
		if alreadyExists {
			return value, nil
		}

		reference, containsReference := variablesInConfig[variable.Reference()]
		if !containsReference {
			return nil, errors.WithStackTrace(MissingReference{VariableName: variable.Name(), ReferenceName: variable.Reference()})
		}
		return GetValueForVariable(reference, variablesInConfig, valuesForPreviousVariables, opts, referenceDepth+1)
	}

	// Run the value we receive from getVariable through validations, ensuring values provided by --var-files will also be checked
	value, err := getVariable(variable, opts)
	if err != nil {
		return value, err
	}
	var result *multierror.Error
	// Run the value through any defined validations for the variable
	for _, customValidation := range variable.Validations() {
		// Run the specific validation against the user-provided value and store it in the map
		err := validation.Validate(value, customValidation.Validator)
		result = multierror.Append(result, err)
	}
	return value, result.ErrorOrNil()
}

// Get a value for the given variable. The value can come from the user (if the non-interactive option isn't set), the
// default value in the config, or a command line option.
func getVariable(variable variables.Variable, opts *options.BoilerplateOptions) (interface{}, error) {
	valueFromVars, valueSpecifiedInVars := getVariableFromVars(variable, opts)

	if valueSpecifiedInVars {
		util.Logger.Printf("Using value specified via command line options for variable '%s': %s", variable.FullName(), valueFromVars)
		return valueFromVars, nil
	} else if opts.NonInteractive && variable.Default() != nil {
		util.Logger.Printf("Using default value for variable '%s': %v", variable.FullName(), variable.Default())
		return variable.Default(), nil
	} else if opts.NonInteractive {
		return nil, errors.WithStackTrace(MissingVariableWithNonInteractiveMode(variable.FullName()))
	} else {
		return getVariableFromUser(variable, opts, variables.InvalidEntries{})
	}
}

// Return the value of the given variable from vars passed in as command line options
func getVariableFromVars(variable variables.Variable, opts *options.BoilerplateOptions) (interface{}, bool) {
	for name, value := range opts.Vars {
		if name == variable.Name() {
			return value, true
		}
	}

	return nil, false
}

// Get the value for the given variable by prompting the user
func getVariableFromUser(variable variables.Variable, opts *options.BoilerplateOptions, invalidEntries variables.InvalidEntries) (interface{}, error) {
	// Add a newline for legibility and padding
	fmt.Println()

	// Show the current variable's name, description, and also render any validation errors in real-time so the user knows what's wrong
	// with their input
	renderVariablePrompts(variable, invalidEntries)

	value, err := getUserInput(variable)
	if err != nil {
		return value, err
	}
	// If any of the variable's validation rules are not satisfied by the user's submission,
	// store the validation errors in a map. We'll then recursively call get_variable_from_user
	// again, this time passing in the validation errors map, so that we can render to the terminal
	// the exact issues with each submission
	validationMap, hasValidationErrs := validateUserInput(value, variable)
	if hasValidationErrs {
		ie := variables.InvalidEntries{
			Issues: []variables.ValidationIssue{
				{
					Value:         value,
					ValidationMap: validationMap,
				},
			},
		}
		return getVariableFromUser(variable, opts, ie)
	}

	if value == "" {
		// TODO: what if the user wanted an empty string instead of the default?
		util.Logger.Printf("Using default value for variable '%s': %v", variable.FullName(), variable.Default())
		return variable.Default(), nil
	}

	return value, nil
}

func getUserInput(variable variables.Variable) (string, error) {
	// Display rich prompts to the user, based on the type of variable we're asking for
	value := ""
	switch variable.Type() {
	case variables.String, variables.Int, variables.Float, variables.Bool, variables.List, variables.Map:
		msg := fmt.Sprintf("Enter a value [type %s]", variable.Type())
		if variable.Default() != nil {
			msg = fmt.Sprintf("%s (default: %v)", msg, variable.Default())
		}
		prompt := &survey.Input{
			Message: msg,
		}
		err := survey.AskOne(prompt, &value)
		if err != nil {
			if err == terminal.InterruptErr {
				log.Fatal("quit")
			}
			return value, err
		}
	case variables.Enum:
		prompt := &survey.Select{
			Message: fmt.Sprintf("Please select %s", variable.FullName()),
			Options: variable.Options(),
		}
		err := survey.AskOne(prompt, &value)
		if err != nil {
			if err == terminal.InterruptErr {
				log.Fatal("quit")
			}
			return value, err
		}
	default:
		if variable.Default() == nil {
			fmt.Println()
			msg := fmt.Sprintf("Variable %s of type '%s' does not support manual input and has no default value.\n"+
				"Please update the variable in the boilerplate.yml file to include a default value or provide a value via the command line using the --var option.",
				pterm.Green(variable.FullName()), variable.Type())
			log.Fatal(msg)
		}
	}
	return value, nil
}

func validateUserInput(value string, variable variables.Variable) (map[string]bool, bool) {
	var valueToValidate interface{}
	if value == "" {
		valueToValidate = variable.Default()
	} else {
		valueToValidate = value
	}

	m := make(map[string]bool)
	hasValidationErrs := false
	for _, customValidation := range variable.Validations() {
		// Run the specific validation against the user-provided value and store it in the map
		err := validation.Validate(valueToValidate, customValidation.Validator)
		val := true
		if err != nil {
			hasValidationErrs = true
			val = false
		}
		m[customValidation.DescriptionText()] = val
	}
	// Validate that the type can be parsed
	if _, err := variables.ConvertType(valueToValidate, variable); err != nil {
		hasValidationErrs = true
		msg := fmt.Sprintf("Value must be of type %s: %s", variable.Type(), err)
		m[msg] = false
	}
	// Validate that the value is not empty if no default is provided
	if value == "" && variable.Default() == nil {
		hasValidationErrs = true
		m["Value must be provided"] = false
	}
	return m, hasValidationErrs
}

// RenderValidationErrors displays in user-legible format the exact validation errors
// that the user's last submission generated
func renderValidationErrors(val interface{}, m map[string]bool) {
	pterm.Warning.WithPrefix(pterm.Prefix{Text: "Invalid entry"}).Println(val)
	for k, v := range m {
		if v {
			pterm.Success.Println(k)
		} else {
			pterm.Error.Println(k)
		}
	}
}

func renderVariablePrompts(variable variables.Variable, invalidEntries variables.InvalidEntries) {
	pterm.Println(pterm.Green(variable.FullName()))

	if variable.Description() != "" {
		pterm.Println(pterm.Yellow(variable.Description()))
	}

	if len(invalidEntries.Issues) > 0 {
		renderValidationErrors(invalidEntries.Issues[0].Value, invalidEntries.Issues[0].ValidationMap)
	}
}

// Custom types
// A KeyAndOrderPair is a composite of the user-defined order and the user's variable name
type KeyAndOrderPair struct {
	Key   string
	Order int
}

// Custom error types

type MissingVariableWithNonInteractiveMode string

func (variableName MissingVariableWithNonInteractiveMode) Error() string {
	return fmt.Sprintf("Variable '%s' does not have a default, no value was specified at the command line using the --%s option, and the --%s flag is set, so cannot prompt user for a value.", string(variableName), options.OptVar, options.OptNonInteractive)
}

type MissingReference struct {
	VariableName  string
	ReferenceName string
}

func (err MissingReference) Error() string {
	return fmt.Sprintf("Variable %s references unknown variable %s", err.VariableName, err.ReferenceName)
}

type CyclicalReference struct {
	VariableName  string
	ReferenceName string
}

func (err CyclicalReference) Error() string {
	return fmt.Sprintf("Variable %s seems to have an cyclical reference with variable %s", err.VariableName, err.ReferenceName)
}
-- config/get_variables_test.go --
package config

import (
	"reflect"
	"testing"

	"golang.org/x/exp/maps"

	"github.com/stretchr/testify/assert"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/variables"
)

func TestGetVariableFromVarsEmptyVars(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo")
	opts := &options.BoilerplateOptions{}

	_, containsValue := getVariableFromVars(variable, opts)
	assert.False(t, containsValue)
}

func TestGetVariableFromVarsNoMatch(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo")
	opts := &options.BoilerplateOptions{
		Vars: map[string]interface{}{
			"key1": "value1",
			"key2": "value2",
			"key3": "value3",
		},
	}

	_, containsValue := getVariableFromVars(variable, opts)
	assert.False(t, containsValue)
}

func TestGetVariableFromVarsMatch(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo")
	opts := &options.BoilerplateOptions{
		Vars: map[string]interface{}{
			"key1": "value1",
			"foo":  "bar",
			"key3": "value3",
		},
	}

	actual, containsValue := getVariableFromVars(variable, opts)
	expected := "bar"

	assert.True(t, containsValue)
	assert.Equal(t, expected, actual)
}

func TestGetVariableFromVarsForDependencyNoMatch(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("bar.foo")
	opts := &options.BoilerplateOptions{
		Vars: map[string]interface{}{
			"key1": "value1",
			"foo":  "bar",
			"key3": "value3",
		},
	}

	_, containsValue := getVariableFromVars(variable, opts)
	assert.False(t, containsValue)
}

func TestGetVariableFromVarsForDependencyMatch(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("bar.foo")
	opts := &options.BoilerplateOptions{
		Vars: map[string]interface{}{
			"key1":    "value1",
			"bar.foo": "bar",
			"key3":    "value3",
		},
	}

	actual, containsValue := getVariableFromVars(variable, opts)
	expected := "bar"

	assert.True(t, containsValue)
	assert.Equal(t, expected, actual)
}

func TestGetVariableNoMatchNonInteractive(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo")
	opts := &options.BoilerplateOptions{NonInteractive: true}

	_, err := getVariable(variable, opts)

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, MissingVariableWithNonInteractiveMode("foo")), "Expected a MissingVariableWithNonInteractiveMode error but got %s", reflect.TypeOf(err))
}

func TestGetVariableInVarsNonInteractive(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo")
	opts := &options.BoilerplateOptions{
		NonInteractive: true,
		Vars: map[string]interface{}{
			"key1": "value1",
			"foo":  "bar",
			"key3": "value3",
		},
	}

	actual, err := getVariable(variable, opts)
	expected := "bar"

	assert.Nil(t, err)
	assert.Equal(t, expected, actual)
}

func TestGetVariableDefaultNonInteractive(t *testing.T) {
	t.Parallel()

	variable := variables.NewStringVariable("foo").WithDefault("bar")
	opts := &options.BoilerplateOptions{
		NonInteractive: true,
		Vars: map[string]interface{}{
			"key1": "value1",
			"key2": "value2",
			"key3": "value3",
		},
	}

	actual, err := getVariable(variable, opts)
	expected := "bar"

	assert.Nil(t, err)
	assert.Equal(t, expected, actual)
}

func TestGetVariablesNoVariables(t *testing.T) {
	t.Parallel()

	opts := &options.BoilerplateOptions{NonInteractive: true}
	boilerplateConfig := &BoilerplateConfig{}
	rootBoilerplateConfig := &BoilerplateConfig{}
	dependency := variables.Dependency{}

	actual, err := GetVariables(opts, boilerplateConfig, rootBoilerplateConfig, dependency)
	expected := map[string]interface{}{
		"BoilerplateConfigVars": map[string]variables.Variable{},
		"BoilerplateConfigDeps": map[string]variables.Dependency{},
		"This": map[string]interface{}{
			"Config":     boilerplateConfig,
			"Options":    opts,
			"CurrentDep": dependency,
		},
	}

	assert.Nil(t, err)
	assert.Equal(t, expected, actual)
}

func TestGetVariablesNoMatchNonInteractive(t *testing.T) {
	t.Parallel()

	opts := &options.BoilerplateOptions{NonInteractive: true}
	boilerplateConfig := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("foo"),
		},
	}
	rootBoilerplateConfig := &BoilerplateConfig{}
	dependency := variables.Dependency{}

	_, err := GetVariables(opts, boilerplateConfig, rootBoilerplateConfig, dependency)

	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, MissingVariableWithNonInteractiveMode("foo")), "Expected a MissingVariableWithNonInteractiveMode error but got %s", reflect.TypeOf(err))
}

func TestGetVariablesMatchFromVars(t *testing.T) {
	t.Parallel()

	opts := &options.BoilerplateOptions{
		NonInteractive: true,
		Vars: map[string]interface{}{
			"foo": "bar",
		},
		OnMissingKey: options.ExitWithError,
	}

	boilerplateConfig := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("foo"),
		},
	}

	rootBoilerplateConfig := &BoilerplateConfig{}

	dependency := variables.Dependency{}

	actual, err := GetVariables(opts, boilerplateConfig, rootBoilerplateConfig, dependency)
	expected := map[string]interface{}{
		"foo":                   "bar",
		"BoilerplateConfigVars": map[string]variables.Variable{},
		"BoilerplateConfigDeps": map[string]variables.Dependency{},
		"This": map[string]interface{}{
			"Config":     boilerplateConfig,
			"Options":    opts,
			"CurrentDep": dependency,
		},
	}

	assert.Nil(t, err)
	assert.Equal(t, expected, actual)
}

func TestGetVariablesMatchFromVarsAndDefaults(t *testing.T) {
	t.Parallel()

	opts := &options.BoilerplateOptions{
		NonInteractive: true,
		Vars: map[string]interface{}{
			"key1": "value1",
			"key2": "value2",
		},
		OnMissingKey: options.ExitWithError,
	}

	boilerplateConfig := &BoilerplateConfig{
		Variables: []variables.Variable{
			variables.NewStringVariable("key1"),
			variables.NewStringVariable("key2"),
			variables.NewStringVariable("key3").WithDefault("value3"),
		},
	}

	rootBoilerplateConfig := &BoilerplateConfig{}

	dependency := variables.Dependency{}

	actual, err := GetVariables(opts, boilerplateConfig, rootBoilerplateConfig, dependency)
	expected := map[string]interface{}{
		"key1":                  "value1",
		"key2":                  "value2",
		"key3":                  "value3",
		"BoilerplateConfigVars": map[string]variables.Variable{},
		"BoilerplateConfigDeps": map[string]variables.Dependency{},
		"This": map[string]interface{}{
			"Config":     boilerplateConfig,
			"Options":    opts,
			"CurrentDep": dependency,
		},
	}

	assert.Nil(t, err)
	assert.Equal(t, expected, actual)
}

func TestValidateUserInput(t *testing.T) {
	t.Parallel()

	// An empty variable with no default value should fail validation
	v := variables.NewStringVariable("foo")
	m, hasValidationErrs := validateUserInput("", v)
	assert.True(t, hasValidationErrs)
	assert.Equal(t, map[string]bool{"Value must be provided": false}, m)

	// An empty variable with a default value should pass validation
	v = variables.NewStringVariable("foo").WithDefault("bar")
	m, hasValidationErrs = validateUserInput("", v)
	assert.False(t, hasValidationErrs)
	assert.Empty(t, m)

	// A non-empty variable should pass validation
	v = variables.NewStringVariable("foo")
	m, hasValidationErrs = validateUserInput("bar", v)
	assert.False(t, hasValidationErrs)
	assert.Empty(t, m)

	// A variable that cannot be parsed should fail validation
	v = variables.NewIntVariable("foo")
	m, hasValidationErrs = validateUserInput("bar", v)
	assert.True(t, hasValidationErrs)
	key := maps.Keys(m)[0]
	assert.Contains(t, key, "Value must be of type int")
}
-- errors/errors.go --
package errors

import (
	"fmt"

	goerrors "github.com/go-errors/errors"
)

// Wrap the given error in an Error type that contains the stack trace. If the given error already has a stack trace,
// it is used directly. If the given error is nil, return nil.
func WithStackTrace(err error) error {
	if err == nil {
		return nil
	}

	return goerrors.Wrap(err, 1)
}

// Wrap the given error in an Error type that contains the stack trace and has the given message prepended as part of
// the error message. If the given error already has a stack trace, it is used directly. If the given error is nil,
// return nil.
func WithStackTraceAndPrefix(err error, message string, args ...interface{}) error {
	if err == nil {
		return nil
	}

	return goerrors.WrapPrefix(err, fmt.Sprintf(message, args...), 1)
}

// Returns true if actual is the same type of error as expected. This method unwraps the given error objects (if they
// are wrapped in objects with a stacktrace) and then does a simple equality check on them.
func IsError(actual error, expected error) bool {
	return goerrors.Is(Unwrap(actual), expected)
}

// If the given error is a wrapper that contains a stacktrace, unwrap it and return the original, underlying error.
// In all other cases, return the error unchanged
func Unwrap(err error) error {
	if err == nil {
		return nil
	}

	goError, isGoError := err.(*goerrors.Error)
	if isGoError {
		return goError.Err
	}

	return err
}

// Convert the given error to a string, including the stack trace if available
func PrintErrorWithStackTrace(err error) string {
	if err == nil {
		return ""
	}

	switch underlyingErr := err.(type) {
	case *goerrors.Error:
		return underlyingErr.ErrorStack()
	default:
		return err.Error()
	}
}
-- getter-helper/file_getter.go --
package getter_helper

import (
	"fmt"
	"net/url"
	"os"

	"github.com/hashicorp/go-getter"

	"github.com/gruntwork-io/boilerplate/util"
)

// A custom getter.Getter implementation that uses file copying instead of symlinks. Symlinks are
// faster and use less disk space, but they cause issues in Windows and with infinite loops, so we copy files/folders
// instead.
type FileCopyGetter struct {
	getter.FileGetter
}

// The original FileGetter does NOT know how to do folder copying (it only does symlinks), so we provide a copy
// implementation here
func (g *FileCopyGetter) Get(dst string, u *url.URL) error {
	path := u.Path
	if u.RawPath != "" {
		path = u.RawPath
	}

	// The source path must exist and be a directory to be usable.
	if fi, err := os.Stat(path); err != nil {
		return fmt.Errorf("source path error: %s", err)
	} else if !fi.IsDir() {
		return fmt.Errorf("source path must be a directory")
	}

	return util.CopyFolder(path, dst)
}

// The original FileGetter already knows how to do file copying so long as we set the Copy flag to true, so just
// delegate to it
func (g *FileCopyGetter) GetFile(dst string, u *url.URL) error {
	underlying := &getter.FileGetter{Copy: true}
	return underlying.GetFile(dst, u)
}
-- getter-helper/getter_helper.go --
package getter_helper

import (
	"context"
	"fmt"
	"net/url"
	"os"
	"path/filepath"
	"regexp"

	getter "github.com/hashicorp/go-getter"
	urlhelper "github.com/hashicorp/go-getter/helper/url"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/util"
)

var forcedRegexp = regexp.MustCompile(`^([A-Za-z0-9]+)::(.+)$`)

// ValidateTemplateUrl returns an error if the template URL is not following one of the supported detector patterns.
func ValidateTemplateUrl(templateUrl string) error {
	_, err := ParseGetterUrl(templateUrl)
	return err
}

func ParseGetterUrl(templateUrl string) (*url.URL, error) {
	pwd, err := os.Getwd()
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}
	getterURLWithGetter, err := getter.Detect(templateUrl, pwd, getter.Detectors)
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}
	return urlParseGetterUrl(getterURLWithGetter)
}

// Parse the given source URL into a URL struct. This method can handle source URLs that include go-getter's "forced
// getter" prefixes, such as git::.
// The following routine was obtained from terragrunt.
func urlParseGetterUrl(rawGetterUrlStr string) (*url.URL, error) {
	forcedGetter, getterUrlStr := getForcedGetter(rawGetterUrlStr)

	// Parse the URL without the getter prefix
	canonicalGetterUrl, err := urlhelper.Parse(getterUrlStr)
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}

	// Reattach the "getter" prefix as part of the scheme
	if forcedGetter != "" {
		canonicalGetterUrl.Scheme = fmt.Sprintf("%s::%s", forcedGetter, canonicalGetterUrl.Scheme)
	}

	return canonicalGetterUrl, nil
}

// Terraform source URLs can contain a "getter" prefix that specifies the type of protocol to use to download that URL,
// such as "git::", which means Git should be used to download the URL. This method returns the getter prefix and the
// rest of the URL. This code is copied from the getForcedGetter method of go-getter/get.go, as that method is not
// exported publicly.
func getForcedGetter(sourceUrl string) (string, string) {
	if matches := forcedRegexp.FindStringSubmatch(sourceUrl); matches != nil && len(matches) > 2 {
		return matches[1], matches[2]
	}

	return "", sourceUrl
}

// We use this code to force go-getter to copy files instead of creating symlinks.
func NewGetterClient(src string, dst string) (*getter.Client, error) {
	pwd, err := os.Getwd()
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}

	client := &getter.Client{
		Ctx:  context.Background(),
		Src:  src,
		Dst:  dst,
		Pwd:  pwd,
		Mode: getter.ClientModeAny,
	}

	// We copy all the default getters from the go-getter library, but replace the "file" getter. We shallow clone the
	// getter map here rather than using getter.Getters directly because we shouldn't change the original,
	// globally-shared getter.Getters map.
	client.Getters = map[string]getter.Getter{}
	for getterName, getterValue := range getter.Getters {
		if getterName == "file" {
			client.Getters[getterName] = &FileCopyGetter{}
		} else {
			client.Getters[getterName] = getterValue
		}
	}

	return client, nil
}

// DownloadTemplatesToTemporaryFolder uses the go-getter library to fetch the templates from the configured URL to a
// temporary folder and returns the path to that folder. If there is a subdir in the template URL, return the combined
// path as well.
func DownloadTemplatesToTemporaryFolder(templateUrl string) (string, string, error) {
	workingDir, err := getTempFolder()
	if err != nil {
		return workingDir, workingDir, errors.WithStackTrace(err)
	}

	// Always set a subdir path because go-getter can not clone into an existing dir.
	cloneDir := filepath.Join(workingDir, "wd")

	util.Logger.Printf("Downloading templates from %s to %s", templateUrl, workingDir)

	// If there is a subdir component, we download everything and combine the path at the end to return the working path
	mainPath, subDir := getter.SourceDirSubdir(templateUrl)
	outDir := filepath.Clean(filepath.Join(cloneDir, subDir))

	client, err := NewGetterClient(mainPath, cloneDir)
	if err != nil {
		return workingDir, outDir, err
	}

	if err := client.Get(); err != nil {
		return workingDir, outDir, err
	}
	return workingDir, outDir, nil
}
-- getter-helper/getter_helper_unix_test.go --
//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris
// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package getter_helper

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/gruntwork-io/go-commons/errors"
	"github.com/gruntwork-io/terratest/modules/git"
	"github.com/gruntwork-io/terratest/modules/shell"
	"github.com/stretchr/testify/require"
)

func TestDownloadTemplatesToTempDir(t *testing.T) {
	t.Parallel()

	pwd, err := os.Getwd()
	require.NoError(t, err)
	examplePath := filepath.Join(pwd, "..", "examples", "for-learning-and-testing", "variables")

	branch := git.GetCurrentBranchName(t)
	templateUrl := fmt.Sprintf("git@github.com:gruntwork-io/boilerplate.git//examples/for-learning-and-testing/variables?ref=%s", branch)
	workingDir, workPath, err := DownloadTemplatesToTemporaryFolder(templateUrl)
	defer os.RemoveAll(workingDir)
	require.NoError(t, err, errors.PrintErrorWithStackTrace(err))

	// Run diff to make sure there are no differences
	cmd := shell.Command{
		Command: "diff",
		Args:    []string{examplePath, workPath},
	}
	shell.RunCommand(t, cmd)
}
-- getter-helper/tmp_path_unix.go --
// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package getter_helper

import (
	"io/ioutil"
)

func getTempFolder() (string, error) {
	return ioutil.TempDir("", "boilerplate-cache*")
}
-- getter-helper/tmp_path_windows.go --
//+build windows

package getter_helper

import (
	"io/ioutil"
	"os"
	"path/filepath"
)

// getTempFolder on Windows will return the computed temporary folder in UNC path to avoid long path issues.
// See https://docs.microsoft.com/en-us/dotnet/standard/io/file-path-formats#unc-paths for more information on Windows Long
// Paths and UNC.
func getTempFolder() (string, error) {
	workingDir, err := ioutil.TempDir("", "boilerplate-cache*")
	if err != nil {
		return workingDir, err
	}
	return fixLongPath(workingDir), err
}

// The following function is copied almost verbatim from
// https://github.com/golang/go/blob/master/src/os/path_windows.go
// with the following modifications:
//
// - Always convert to long form (this is so that it stays long form even after elements are appended to the path)
// - Reference functions in the stdlib as opposed to internal private funcs.
//
// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.
//
// fixLongPath returns the extended-length (\\?\-prefixed) form of
// path when needed, in order to avoid the default 260 character file
// path limit imposed by Windows. If path is not easily converted to
// the extended-length form (for example, if path is a relative path
// or contains .. elements), or is short enough, fixLongPath returns
// path unmodified.
//
// See https://msdn.microsoft.com/en-us/library/windows/desktop/aa365247(v=vs.85).aspx#maxpath
func fixLongPath(path string) string {
	// The extended form begins with \\?\, as in
	// \\?\c:\windows\foo.txt or \\?\UNC\server\share\foo.txt.
	// The extended form disables evaluation of . and .. path
	// elements and disables the interpretation of / as equivalent
	// to \. The conversion here rewrites / to \ and elides
	// . elements as well as trailing or duplicate separators. For
	// simplicity it avoids the conversion entirely for relative
	// paths or paths containing .. elements. For now,
	// \\server\share paths are not converted to
	// \\?\UNC\server\share paths because the rules for doing so
	// are less well-specified.
	if len(path) >= 2 && path[:2] == `\\` {
		// Don't canonicalize UNC paths.
		return path
	}
	if !filepath.IsAbs(path) {
		// Relative path
		return path
	}

	const prefix = `\\?`

	pathbuf := make([]byte, len(prefix)+len(path)+len(`\`))
	copy(pathbuf, prefix)
	n := len(path)
	r, w := 0, len(prefix)
	for r < n {
		switch {
		case os.IsPathSeparator(path[r]):
			// empty block
			r++
		case path[r] == '.' && (r+1 == n || os.IsPathSeparator(path[r+1])):
			// /./
			r++
		case r+1 < n && path[r] == '.' && path[r+1] == '.' && (r+2 == n || os.IsPathSeparator(path[r+2])):
			// /../ is currently unhandled
			return path
		default:
			pathbuf[w] = '\\'
			w++
			for ; r < n && !os.IsPathSeparator(path[r]); r++ {
				pathbuf[w] = path[r]
				w++
			}
		}
	}
	// A drive's root directory needs a trailing \
	if w == len(`\\?\c:`) {
		pathbuf[w] = '\\'
		w++
	}
	return string(pathbuf[:w])
}
-- integration-tests/envvars_test.go --
package integration_tests

import (
	"os"
	"strings"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/gruntwork-io/boilerplate/cli"
	"github.com/gruntwork-io/boilerplate/errors"
)

// Our integration tests run through all the examples in the /examples/for-learning-and-testing folder, generate them,
// and check that they produce the output in /test-fixtures/examples-expected-output
func TestEnvVarExample(t *testing.T) {
	app := cli.CreateBoilerplateCli()

	tempdir := t.TempDir()

	args := []string{
		"boilerplate",
		"--template-url",
		"../test-fixtures/env-vars",
		"--output-folder",
		tempdir,
		"--non-interactive",
	}

	err := app.Run(args)
	require.NoError(t, err, errors.PrintErrorWithStackTrace(err))

	testTxt := tempdir + "/target.txt"
	assert.FileExists(t, testTxt)
	content, err := os.ReadFile(testTxt)
	require.NoError(t, err)
	assert.Equal(t, "default-value", strings.TrimSpace(string(content)))

	t.Setenv("BOILERPLATE_ValueFromEnvVar", "env-var-value")
	err = app.Run(args)
	require.NoError(t, err, errors.PrintErrorWithStackTrace(err))

	content, err = os.ReadFile(testTxt)
	require.NoError(t, err)
	assert.Equal(t, "env-var-value", strings.TrimSpace(string(content)))
}
-- integration-tests/error_message_test.go --
package integration_tests

import (
	"io/ioutil"
	"os"
	"testing"

	"github.com/gruntwork-io/boilerplate/cli"
	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestMisspelledTemplateURLErrorMessage(t *testing.T) {
	t.Parallel()

	templateFolder := "../test-fixtures/regression-test/misspelled-git"

	outputFolder, err := ioutil.TempDir("", "boilerplate-test-output")
	require.NoError(t, err)
	defer os.RemoveAll(outputFolder)

	app := cli.CreateBoilerplateCli()
	args := []string{
		"boilerplate",
		"--template-url",
		templateFolder,
		"--output-folder",
		outputFolder,
		"--non-interactive",
	}
	runErr := app.Run(args)
	assert.Error(t, runErr, errors.PrintErrorWithStackTrace(runErr))
	assert.Contains(t, runErr.Error(), "Did you misspell the URL")
}
-- integration-tests/for_production_example_unix_test.go --
//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris
// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package integration_tests

import (
	"io/ioutil"
	"path/filepath"
	"testing"

	"github.com/gruntwork-io/terratest/modules/terraform"
	"github.com/stretchr/testify/require"

	"github.com/gruntwork-io/boilerplate/options"
)

func TestForProductionTerragruntArchitectureBoilerplateExample(t *testing.T) {
	t.Parallel()

	forProductionExamplePath := "../examples/for-production/terragrunt-architecture-catalog"

	outputBasePath, err := ioutil.TempDir("", "boilerplate-for-production-output")
	require.NoError(t, err)
	//defer os.RemoveAll(outputBasePath)

	templateFolder, err := filepath.Abs(filepath.Join(forProductionExamplePath, "blueprints", "reference-architecture"))
	require.NoError(t, err)
	outputFolder := filepath.Join(outputBasePath, "infrastructure-live")
	varFile, err := filepath.Abs(filepath.Join(forProductionExamplePath, "sample_reference_architecture_vars.yml"))
	require.NoError(t, err)

	testExample(t, templateFolder, outputFolder, varFile, "", string(options.ExitWithError))

	// Make sure it rendered valid terragrunt outputs by running terragrunt validate in each of the relevant folders.
	t.Run("group", func(t *testing.T) {
		for _, account := range []string{"dev", "stage", "prod"} {
			opts := &terraform.Options{
				TerraformBinary: "terragrunt",
				TerraformDir:    filepath.Join(outputFolder, account),
			}
			t.Run(account, func(t *testing.T) {
				t.Parallel()
				_, tfErr := terraform.RunTerraformCommandE(t, opts, terraform.FormatArgs(opts, "validate-all")...)
				require.NoError(t, tfErr)
			})
		}
	})
}
-- integration-tests/required_version_test.go --
package integration_tests

import (
	"io/ioutil"
	"os"
	"testing"

	"github.com/gruntwork-io/boilerplate/cli"
	"github.com/gruntwork-io/boilerplate/config"
	"github.com/gruntwork-io/go-commons/errors"
	"github.com/gruntwork-io/go-commons/version"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

const (
	testVersion = "v1.33.7"
)

func TestRequiredVersionMatchCase(t *testing.T) {
	t.Parallel()

	// Make sure that the test is run with the ld flags setting version to our expected test version.
	require.Equal(t, testVersion, version.GetVersion())

	require.NoError(
		t,
		runRequiredVersionExample(t, "../test-fixtures/regression-test/required-version/match"),
	)
}

func TestRequiredVersionOverTest(t *testing.T) {
	t.Parallel()

	// Make sure that the test is run with the ld flags setting version to our expected test version.
	require.Equal(t, testVersion, version.GetVersion())

	err := runRequiredVersionExample(t, "../test-fixtures/regression-test/required-version/over-test")
	assert.Error(t, err)

	errUnwrapped := errors.Unwrap(err)
	_, isInvalidVersionErr := errUnwrapped.(config.InvalidBoilerplateVersion)
	assert.True(t, isInvalidVersionErr)
}

func TestRequiredVersionUnderTest(t *testing.T) {
	t.Parallel()

	// Make sure that the test is run with the ld flags setting version to our expected test version.
	require.Equal(t, testVersion, version.GetVersion())

	require.NoError(
		t,
		runRequiredVersionExample(t, "../test-fixtures/regression-test/required-version/under-test"),
	)
}

func runRequiredVersionExample(t *testing.T, templateFolder string) error {
	app := cli.CreateBoilerplateCli()

	outputPath, err := ioutil.TempDir("", "boilerplate-test-output-reqver")
	require.NoError(t, err)
	defer os.RemoveAll(outputPath)

	args := []string{
		"boilerplate",
		"--template-url",
		templateFolder,
		"--output-folder",
		outputPath,
		"--non-interactive",
	}
	return app.Run(args)
}
-- integration-tests/slice_parsing_test.go --
package integration_tests

import (
	"fmt"
	"os"
	"path/filepath"
	"testing"

	"github.com/gruntwork-io/boilerplate/cli"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Test that we can pass --var values with commas and spaces, and that those are parsed as a single value, rather than
// multiple.
func TestSliceParsing(t *testing.T) {
	t.Parallel()

	templateFolder := "../test-fixtures/regression-test/slice-parsing"

	outputFolder, err := os.MkdirTemp("", "boilerplate-test-output")
	require.NoError(t, err)
	defer os.RemoveAll(outputFolder)

	mapValue := `{"key1":"value1","key2":"value2","key3":"value3"}`

	app := cli.CreateBoilerplateCli()
	args := []string{
		"boilerplate",
		"--template-url",
		templateFolder,
		"--output-folder",
		outputFolder,
		"--var",
		fmt.Sprintf("MapValue=%s", mapValue),
		"--non-interactive",
	}

	runErr := app.Run(args)
	require.NoError(t, runErr)

	outputPath := filepath.Join(outputFolder, "output.txt")

	// Check the JSON we passed in via the CLI got through without any modifications
	bytes, err := os.ReadFile(outputPath)
	require.NoError(t, err)
	assert.Equal(t, mapValue, string(bytes))
}
-- integration-tests/test_helpers_unix.go --
// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package integration_tests

import (
	"strings"
	"testing"

	"github.com/gruntwork-io/terratest/modules/files"
	"github.com/gruntwork-io/terratest/modules/shell"
	"github.com/stretchr/testify/require"
)

// Diffing two directories to ensure they have the exact same files, contents, etc and showing exactly what's different
// takes a lot of code. Why waste time on that when this functionality is already nicely implemented in the Unix/Linux
// "diff" command? We shell out to that command at test time.
func assertDirectoriesEqual(t *testing.T, folderWithExpectedContents string, folderWithActualContents string) {
	// Copy the folder contents to a temp dir for testing purposes without .keep-dir files, which are used to ensure the
	// directory exists in git.
	tmpFolder, err := files.CopyFolderToTemp(folderWithExpectedContents, "boilerplate-assert-direq-", func(path string) bool {
		return !strings.HasSuffix(path, ".keep-dir")
	})
	require.NoError(t, err)

	cmd := shell.Command{
		Command: "diff",
		Args:    []string{"-r", "-u", tmpFolder, folderWithActualContents},
	}
	shell.RunCommand(t, cmd)
}
-- integration-tests/test_helpers_windows.go --
//+build windows

package integration_tests

import (
	"fmt"
	"os/exec"
	"testing"

	"github.com/gruntwork-io/terratest/modules/shell"
	"github.com/stretchr/testify/require"
)

// Like Unix/Linux, diffing two files is relatively easier than golang native functions in powershell.
// Get the contents of each folder and then compare them.
// Inspired by https://devblogs.microsoft.com/scripting/easily-compare-two-folders-by-using-powershell/
func assertDirectoriesEqual(t *testing.T, folderWithExpectedContents string, folderWithActualContents string) {
	powershellDiffTemplate := `$fone = Get-ChildItem -Recurse -path %s
$ftwo = Get-ChildItem -Recurse -path %s
Compare-Object -ReferenceObject $fone -DifferenceObject $ftwo
`
	powershellDiffCmd := fmt.Sprintf(powershellDiffTemplate, folderWithExpectedContents, folderWithActualContents)
	runPowershell(t, powershellDiffCmd)
}

func runPowershell(t *testing.T, args ...string) {
	ps, err := exec.LookPath("powershell.exe")
	require.NoError(t, err)

	psArgs := append([]string{"-NoProfile", "-NonInteractive"}, args...)
	cmd := shell.Command{
		Command: ps,
		Args:    psArgs,
	}
	shell.RunCommand(t, cmd)
}
-- main.go --
package main

import (
	"github.com/gruntwork-io/go-commons/entrypoint"

	"github.com/gruntwork-io/boilerplate/cli"
)

// The main entrypoint for boilerplate
func main() {
	app := cli.CreateBoilerplateCli()
	entrypoint.RunApp(app)
}
-- options/options.go --
package options

import (
	"fmt"

	"github.com/urfave/cli/v2"

	"github.com/gruntwork-io/boilerplate/errors"
	getter_helper "github.com/gruntwork-io/boilerplate/getter-helper"
	"github.com/gruntwork-io/boilerplate/variables"
)

const OptTemplateUrl = "template-url"
const OptOutputFolder = "output-folder"
const OptNonInteractive = "non-interactive"
const OptVar = "var"
const OptVarFile = "var-file"
const OptMissingKeyAction = "missing-key-action"
const OptMissingConfigAction = "missing-config-action"
const OptDisableHooks = "disable-hooks"
const OptDisableShell = "disable-shell"
const OptDisableDependencyPrompt = "disable-dependency-prompt"

// The command-line options for the boilerplate app
type BoilerplateOptions struct {
	// go-getter supported URL where the template can be sourced.
	TemplateUrl string
	// Working directory where the go-getter defined template is downloaded.
	TemplateFolder string

	OutputFolder            string
	NonInteractive          bool
	Vars                    map[string]interface{}
	OnMissingKey            MissingKeyAction
	OnMissingConfig         MissingConfigAction
	DisableHooks            bool
	DisableShell            bool
	DisableDependencyPrompt bool
}

// Validate that the options have reasonable values and return an error if they don't
func (options *BoilerplateOptions) Validate() error {
	if options.TemplateUrl == "" {
		return errors.WithStackTrace(TemplateUrlOptionCannotBeEmpty)
	}

	if err := getter_helper.ValidateTemplateUrl(options.TemplateUrl); err != nil {
		return err
	}

	if options.OutputFolder == "" {
		return errors.WithStackTrace(OutputFolderOptionCannotBeEmpty)
	}

	return nil
}

// Parse the command line options provided by the user
func ParseOptions(cliContext *cli.Context) (*BoilerplateOptions, error) {
	vars, err := variables.ParseVars(cliContext.StringSlice(OptVar), cliContext.StringSlice(OptVarFile))
	if err != nil {
		return nil, err
	}

	missingKeyAction := DefaultMissingKeyAction
	missingKeyActionValue := cliContext.String(OptMissingKeyAction)
	if missingKeyActionValue != "" {
		missingKeyAction, err = ParseMissingKeyAction(missingKeyActionValue)
		if err != nil {
			return nil, err
		}
	}

	missingConfigAction := DefaultMissingConfigAction
	missingConfigActionValue := cliContext.String(OptMissingConfigAction)
	if missingConfigActionValue != "" {
		missingConfigAction, err = ParseMissingConfigAction(missingConfigActionValue)
		if err != nil {
			return nil, err
		}
	}

	templateUrl, templateFolder, err := DetermineTemplateConfig(cliContext.String(OptTemplateUrl))
	if err != nil {
		return nil, err
	}

	options := &BoilerplateOptions{
		TemplateUrl:             templateUrl,
		TemplateFolder:          templateFolder,
		OutputFolder:            cliContext.String(OptOutputFolder),
		NonInteractive:          cliContext.Bool(OptNonInteractive),
		OnMissingKey:            missingKeyAction,
		OnMissingConfig:         missingConfigAction,
		Vars:                    vars,
		DisableHooks:            cliContext.Bool(OptDisableHooks),
		DisableShell:            cliContext.Bool(OptDisableShell),
		DisableDependencyPrompt: cliContext.Bool(OptDisableDependencyPrompt),
	}

	if err := options.Validate(); err != nil {
		return nil, err
	}

	return options, nil
}

// DetermineTemplateConfig decides what should be passed to TemplateUrl and TemplateFolder. This parses the templateUrl
// and determines if it is a local path. If so, use that path directly instead of downloading it to a temp working dir.
// We do this by setting the template folder, which will instruct the process routine to skip downloading the template.
// Returns TemplateUrl, TemplateFolder, error
func DetermineTemplateConfig(templateUrl string) (string, string, error) {
	url, err := getter_helper.ParseGetterUrl(templateUrl)
	if err != nil {
		return "", "", err
	}
	if url.Scheme == "file" {
		// Intentionally return as both TemplateUrl and TemplateFolder so that validation passes, but still skip
		// download.
		return templateUrl, templateUrl, nil
	}
	return templateUrl, "", nil
}

// This type is an enum that represents what we can do when a template looks up a missing key. This typically happens
// when there is a typo in the variable name in a template.
type MissingKeyAction string

var (
	Invalid       = MissingKeyAction("invalid") // print <no value> for any missing key
	ZeroValue     = MissingKeyAction("zero")    // print the zero value of the missing key
	ExitWithError = MissingKeyAction("error")   // exit with an error when there is a missing key
)

var AllMissingKeyActions = []MissingKeyAction{Invalid, ZeroValue, ExitWithError}
var DefaultMissingKeyAction = ExitWithError

// Convert the given string to a MissingKeyAction enum, or return an error if this is not a valid value for the
// MissingKeyAction enum
func ParseMissingKeyAction(str string) (MissingKeyAction, error) {
	for _, missingKeyAction := range AllMissingKeyActions {
		if string(missingKeyAction) == str {
			return missingKeyAction, nil
		}
	}
	return MissingKeyAction(""), errors.WithStackTrace(InvalidMissingKeyAction(str))
}

// This type is an enum that represents what to do when the template folder passed to boilerplate does not contain a
// boilerplate.yml file.
type MissingConfigAction string

var (
	Exit   = MissingConfigAction("exit")
	Ignore = MissingConfigAction("ignore")
)
var AllMissingConfigActions = []MissingConfigAction{Exit, Ignore}
var DefaultMissingConfigAction = Exit

// Convert the given string to a MissingConfigAction enum, or return an error if this is not a valid value for the
// MissingConfigAction enum
func ParseMissingConfigAction(str string) (MissingConfigAction, error) {
	for _, missingConfigAction := range AllMissingConfigActions {
		if string(missingConfigAction) == str {
			return missingConfigAction, nil
		}
	}
	return MissingConfigAction(""), errors.WithStackTrace(InvalidMissingConfigAction(str))
}

// Custom error types

var TemplateUrlOptionCannotBeEmpty = fmt.Errorf("The --%s option cannot be empty", OptTemplateUrl)
var OutputFolderOptionCannotBeEmpty = fmt.Errorf("The --%s option cannot be empty", OptOutputFolder)

type InvalidMissingKeyAction string

func (err InvalidMissingKeyAction) Error() string {
	return fmt.Sprintf("Invalid MissingKeyAction '%s'. Value must be one of: %s", string(err), AllMissingKeyActions)
}

type InvalidMissingConfigAction string

func (err InvalidMissingConfigAction) Error() string {
	return fmt.Sprintf("Invalid MissingConfigAction '%s'. Value must be one of: %s", string(err), AllMissingConfigActions)
}
-- render/render_jsonnet.go --
package render

import (
	"encoding/json"

	jsonnet "github.com/google/go-jsonnet"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/util"
)

// The following variables need to be stripped as it can't be rendered into json.
var incompatibleVariables = []string{
	"This",
}

// RenderJsonnetTemplate renders the jsonnet template at templatePath to the target location specified in the
// boilerplate options, passing in the boilerplate variables as Top Level Arguments. Note that this function will also
// make available the following helper values as External variables:
//
// - templateFolder
// - outputFolder
//
func RenderJsonnetTemplate(
	templatePath string,
	variables map[string]interface{},
	opts *options.BoilerplateOptions,
) (string, error) {
	jsonnetVM := jsonnet.MakeVM()
	configureExternalVars(opts, jsonnetVM)
	if err := configureTLAVarsFromBoilerplateVars(jsonnetVM, variables); err != nil {
		return "", err
	}
	output, err := jsonnetVM.EvaluateFile(templatePath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	return output, nil
}

// configureExternalVars registers the helper values as external variables for the jsonnet template engine.
func configureExternalVars(opts *options.BoilerplateOptions, vm *jsonnet.VM) {
	vm.ExtVar("templateFolder", opts.TemplateFolder)
	vm.ExtVar("outputFolder", opts.OutputFolder)
}

// configureTLAVarsFromBoilerplateVars translates the boilerplate variables into jsonnet values to make accessible to
// the top level function. Each boilerplate variable will be nested in an object boilerplateVars to avoid requiring
// every variable be defined.
// To pass through the boilerplate variables, we cheat by using json as an intermediary representation.
func configureTLAVarsFromBoilerplateVars(vm *jsonnet.VM, vars map[string]interface{}) error {
	// Some of the auto injected vars are not json marshable at the moment, so we skip those.
	jsonCompatibleMap := map[string]interface{}{}
	for k, v := range vars {
		if util.ListContains(k, incompatibleVariables) == false {
			jsonCompatibleMap[k] = v
		}
	}

	jsonBytes, err := json.Marshal(jsonCompatibleMap)
	if err != nil {
		return errors.WithStackTrace(err)
	}
	vm.TLACode("boilerplateVars", string(jsonBytes))
	return nil
}
-- render/render_jsonnet_unix_test.go --
//go:build aix || darwin || dragonfly || freebsd || (js && wasm) || linux || netbsd || openbsd || solaris
// +build aix darwin dragonfly freebsd js,wasm linux netbsd openbsd solaris

package render

import (
	"encoding/json"
	"io/ioutil"
	"path/filepath"
	"testing"

	zglob "github.com/mattn/go-zglob"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"

	"github.com/gruntwork-io/boilerplate/options"
)

func TestRenderJsonnet(t *testing.T) {
	t.Parallel()

	testFolders, err := zglob.Glob("../test-fixtures/jsonnet-unit-test/*")
	require.NoError(t, err)

	testBoilerplateOptions := &options.BoilerplateOptions{
		TemplateFolder: "/path/to/template",
		OutputFolder:   "/path/to/output",
	}

	for _, folder := range testFolders {
		testCaseName := filepath.Base(folder)
		templateFPath := filepath.Join(folder, "template.jsonnet")
		expectedFPath := filepath.Join(folder, "expected.json")
		variablesFPath := filepath.Join(folder, "variables.json")

		t.Run(testCaseName, func(t *testing.T) {
			t.Parallel()

			variablesJson, err := ioutil.ReadFile(variablesFPath)
			require.NoError(t, err)

			var variables map[string]interface{}
			require.NoError(t, json.Unmarshal(variablesJson, &variables))

			outputJson, err := RenderJsonnetTemplate(templateFPath, variables, testBoilerplateOptions)
			require.NoError(t, err)
			var output map[string]interface{}
			require.NoError(t, json.Unmarshal([]byte(outputJson), &output))

			expectedOutputJson, err := ioutil.ReadFile(expectedFPath)
			require.NoError(t, err)
			var expectedOutput map[string]interface{}
			require.NoError(t, json.Unmarshal(expectedOutputJson, &expectedOutput))

			assert.Equal(t, expectedOutput, output)
		})
	}
}
-- render/render_template.go --
package render

import (
	"bytes"
	"fmt"
	"path"
	"reflect"
	"text/template"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/hashicorp/go-multierror"
)

const MaxRenderAttempts = 15

// RenderTemplateWithPartials renders the template at templatePath with the contents of the root template (the template
// named by the user on the command line) as well as all of the partials matched by the provided globs using the Go
// template engine, passing in the given variables as data.
func RenderTemplateWithPartials(templatePath string, partials []string, variables map[string]interface{}, opts *options.BoilerplateOptions) (string, error) {
	tmpl, err := getTemplate(templatePath, opts).ParseGlob(templatePath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	// Each item in the list of partials is a glob to a path relative to the templatePath, so we need to
	// first resolve the path, then parse all the files matching the glob. Finally, we add all the templates
	// found in each glob to the tree.
	for _, globOfPartials := range partials {
		// Use opts.TemplateFolder because the templatePath may be a subdir, but the partial paths are
		// relative to the path passed in by the user
		relativePath := PathRelativeToTemplate(opts.TemplateFolder, globOfPartials)
		parsedTemplate, err := getTemplate(templatePath, opts).ParseGlob(relativePath)
		if err != nil {
			return "", errors.WithStackTrace(err)
		}
		for _, t := range parsedTemplate.Templates() {
			tmpl.AddParseTree(t.Name(), t.Tree)
		}
	}
	return executeTemplate(tmpl, variables)
}

// Render the template at templatePath, with contents templateContents, using the Go template engine, passing in the
// given variables as data.
func RenderTemplateFromString(templatePath string, templateContents string, variables map[string]interface{}, opts *options.BoilerplateOptions) (string, error) {
	tmpl := getTemplate(templatePath, opts)
	parsedTemplate, err := tmpl.Parse(templateContents)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	return executeTemplate(parsedTemplate, variables)
}

// getTemplate returns new template initialized with options and helper functions
func getTemplate(templatePath string, opts *options.BoilerplateOptions) *template.Template {
	tmpl := template.New(path.Base(templatePath))
	option := fmt.Sprintf("missingkey=%s", string(opts.OnMissingKey))
	return tmpl.Funcs(CreateTemplateHelpers(templatePath, opts, tmpl)).Option(option)
}

// executeTemplate executes a parsed template with a given set of variable inputs and return the output as a string
func executeTemplate(tmpl *template.Template, variables map[string]interface{}) (string, error) {
	var output bytes.Buffer
	if err := tmpl.Execute(&output, variables); err != nil {
		return "", errors.WithStackTrace(err)
	}
	return output.String(), nil
}

// RenderVariables will render each of the variables that need to be rendered by running it through the go templating
// syntax. Variable values are allowed to use Go templating syntax (e.g. to reference other variables), so this function
// loops over each variable value, renders each one, and returns a new map of rendered variables.
//
// This function supports nested variables references, but uses a heuristic based approach. Ideally, we can parse the Go
// template and build up a graph of variable dependencies to assist with the rendering process, but this takes a lot of
// effort to get right and maintain.
//
// Instead, we opt for a simpler approach of rendering with multiple trials. In this approach, we continuously attempt
// to render the template on the variable until all of them render without errors, or we reach the maximum trials. To
// support this, we ignore the missing key configuration during this evaluation pass and always rely on the template
// erroring for missing variables. Otherwise, all the variables will render on the first pass.
//
// Note that this is NOT a multi pass algorithm - that is, we do NOT attempt to render the template multiple times.
// Instead, we do a single template render on each run and reject any that return with an error.
func RenderVariables(
	opts *options.BoilerplateOptions,
	variablesToRender map[string]interface{},
	alreadyRenderedVariables map[string]interface{},
) (map[string]interface{}, error) {
	// Force to use ExitWithError for missing key, because by design this algorithm depends on boilerplate error-ing if
	// a variable can't be rendered due to a reference that hasn't been rendered yet. If OnMissingKey was invalid or
	// zero, then boilerplate will automatically render all references to `"<no-value>"` or `""` in the first pass.
	//
	// We can do this because this option should only apply to the leaf variables (variables with no references), and
	// the leaf variables are handled by the time it gets to this function in the `alreadyRenderedVariables` map that is
	// passed in.
	//
	// NOTE: here, I am copying by value, not by reference by deferencing the pointer when assigning to optsForRender.
	// This ensures that opts (whatever caller passed in) doesn't change in this routine.
	optsForRender := *opts
	optsForRender.OnMissingKey = options.ExitWithError

	unrenderedVariables := []string{}
	for variableName := range variablesToRender {
		unrenderedVariables = append(unrenderedVariables, variableName)
	}

	var renderErr error
	renderedVariables := alreadyRenderedVariables
	rendered := true
	for iterations := 0; len(unrenderedVariables) > 0 && rendered; iterations++ {
		if iterations > MaxRenderAttempts {
			// Reached maximum supported iterations, which is most likely an infinite loop bug so cut the iteration
			// short an return an error.
			return nil, errors.WithStackTrace(MaxRenderAttemptsErr{})
		}

		attemptRenderOutput, err := attemptRenderVariables(&optsForRender, unrenderedVariables, renderedVariables, variablesToRender)
		unrenderedVariables = attemptRenderOutput.unrenderedVariables
		renderedVariables = attemptRenderOutput.renderedVariables
		rendered = attemptRenderOutput.variablesWereRendered
		renderErr = err
	}
	if len(unrenderedVariables) > 0 {
		return nil, renderErr
	}

	return renderedVariables, nil
}

// attemptRenderVariables is a helper function that drives the multiple trial algorithm. This represents a single trial
// of evaluating all the unrendered variables. This function goes through each unrendered variable and attempts to
// render them using the currently rendered variables. This will return:
// - all the variables that are still unrendered after this attempt
// - the updated map of rendered variables
// - a boolean indicating whether any new variables were rendered
func attemptRenderVariables(
	opts *options.BoilerplateOptions,
	unrenderedVariables []string,
	renderedVariables map[string]interface{},
	variables map[string]interface{},
) (attemptRenderVariablesOutput, error) {
	newUnrenderedVariables := []string{}
	wasRendered := false

	var allRenderErr error
	for _, variableName := range unrenderedVariables {
		rendered, err := attemptRenderVariable(opts, variables[variableName], renderedVariables)
		if err != nil {
			newUnrenderedVariables = append(newUnrenderedVariables, variableName)
			allRenderErr = multierror.Append(allRenderErr, err)
		} else {
			renderedVariables[variableName] = rendered
			wasRendered = true
		}
	}
	out := attemptRenderVariablesOutput{
		unrenderedVariables:   newUnrenderedVariables,
		renderedVariables:     renderedVariables,
		variablesWereRendered: wasRendered,
	}
	return out, allRenderErr
}

// attemptRenderVariable renders a single variable, using the provided renderedVariables to resolve any variable
// references.
// NOTE: This function is not responsible for converting the output type to the expected type configured on the
// boilerplate config, and will always use string as the primitive output.
func attemptRenderVariable(opts *options.BoilerplateOptions, variable interface{}, renderedVariables map[string]interface{}) (interface{}, error) {
	valueType := reflect.ValueOf(variable)

	switch valueType.Kind() {
	case reflect.String:
		return RenderTemplateFromString(opts.TemplateFolder, variable.(string), renderedVariables, opts)
	case reflect.Slice:
		values := []interface{}{}
		for i := 0; i < valueType.Len(); i++ {
			rendered, err := attemptRenderVariable(opts, valueType.Index(i).Interface(), renderedVariables)
			if err != nil {
				return nil, err
			}
			values = append(values, rendered)
		}
		return values, nil
	case reflect.Map:
		values := map[string]interface{}{}
		for _, key := range valueType.MapKeys() {
			renderedKey, err := attemptRenderVariable(opts, key.Interface(), renderedVariables)
			if err != nil {
				return nil, err
			}
			renderedValue, err := attemptRenderVariable(opts, valueType.MapIndex(key).Interface(), renderedVariables)
			if err != nil {
				return nil, err
			}
			values[renderedKey.(string)] = renderedValue
		}
		return values, nil
	default:
		return variable, nil
	}
}

// Return types

type attemptRenderVariablesOutput struct {
	unrenderedVariables   []string
	renderedVariables     map[string]interface{}
	variablesWereRendered bool
}

// Custom error types

type MaxRenderAttemptsErr struct{}

func (err MaxRenderAttemptsErr) Error() string {
	return fmt.Sprintf(`Reached maximum supported iterations for rendering variables. This can happen if you have:
- cyclic variable references
- deeper than supported variable references (max depth: %d)
`, MaxRenderAttempts)
}
-- render/render_template_test.go --
package render

import (
	"fmt"
	"os"
	"runtime"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/gruntwork-io/boilerplate/options"
)

const EMBED_WHOLE_FILE_TEMPLATE = `
embed file:
{{`{{`}}snippet "../test-fixtures/templates-test/full-file-snippet.txt"}}
`

const EMBED_WHOLE_FILE_TEMPLATE_OUTPUT = `
embed file:
Hi
boilerplate-snippet: foo
Hello, World!
boilerplate-snippet: foo
Bye
`

const EMBED_SNIPPET_TEMPLATE = `
embed snippet:
{{`{{`}}snippet "../test-fixtures/templates-test/full-file-snippet.txt" "foo"}}
`

const EMBED_SNIPPET_TEMPLATE_OUTPUT = `
embed snippet:
Hello, World!
`

func TestRenderTemplate(t *testing.T) {
	t.Parallel()

	pwd, err := os.Getwd()
	assert.Nil(t, err, "Couldn't get working directory")

	// Read an environment variable that's probably present on all systems so we can check that the env helper
	// returns the same value
	userFromEnvVar := os.Getenv("USER")

	defaultOutputDir := "/output"
	defaultTemplateDir := "/templates"
	if runtime.GOOS == "windows" {
		defaultOutputDir = "C:\\output"
		defaultTemplateDir = "C:\\templates"
	}

	testCases := []struct {
		templateContents  string
		variables         map[string]interface{}
		missingKeyAction  options.MissingKeyAction
		expectedErrorText string
		expectedOutput    string
		skip              bool // flag to skip tests
	}{
		{"", map[string]interface{}{}, options.ExitWithError, "", "", false},
		{"plain text template", map[string]interface{}{}, options.ExitWithError, "", "plain text template", false},
		{"variable lookup: {{`{{`}}.Foo}}", map[string]interface{}{"Foo": "bar"}, options.ExitWithError, "", "variable lookup: bar", false},
		{"missing variable lookup, ExitWithError: {{`{{`}}.Foo}}", map[string]interface{}{}, options.ExitWithError, "map has no entry for key \"Foo\"", "", false},
		{"missing variable lookup, Invalid: {{`{{`}}.Foo}}", map[string]interface{}{}, options.Invalid, "", "missing variable lookup, Invalid: <no value>", false},
		// Note: options.ZeroValue does not work correctly with Go templating when you pass in a map[string]interface{}. For some reason, it always prints <no value>.
		{"missing variable lookup, ZeroValue: {{`{{`}}.Foo}}", map[string]interface{}{}, options.ZeroValue, "", "missing variable lookup, ZeroValue: <no value>", false},
		{EMBED_WHOLE_FILE_TEMPLATE, map[string]interface{}{}, options.ExitWithError, "", EMBED_WHOLE_FILE_TEMPLATE_OUTPUT, runtime.GOOS == "windows"},
		{EMBED_SNIPPET_TEMPLATE, map[string]interface{}{}, options.ExitWithError, "", EMBED_SNIPPET_TEMPLATE_OUTPUT, false},
		{"Invalid template syntax: {{`{{`}}.Foo", map[string]interface{}{}, options.ExitWithError, "unclosed action", "", false},
		{"Uppercase test: {{`{{`}} .Foo | upcase }}", map[string]interface{}{"Foo": "some text"}, options.ExitWithError, "", "Uppercase test: SOME TEXT", false},
		{"Lowercase test: {{`{{`}} .Foo | downcase }}", map[string]interface{}{"Foo": "SOME TEXT"}, options.ExitWithError, "", "Lowercase test: some text", false},
		{"Capitalize test: {{`{{`}} .Foo | capitalize }}", map[string]interface{}{"Foo": "some text"}, options.ExitWithError, "", "Capitalize test: Some Text", false},
		{"Replace test: {{`{{`}} .Foo | replace \"foo\" \"bar\" }}", map[string]interface{}{"Foo": "hello foo, how are foo"}, options.ExitWithError, "", "Replace test: hello bar, how are foo", false},
		{"Replace all test: {{`{{`}} .Foo | replaceAll \"foo\" \"bar\" }}", map[string]interface{}{"Foo": "hello foo, how are foo"}, options.ExitWithError, "", "Replace all test: hello bar, how are bar", false},
		{"Trim test: {{`{{`}} .Foo | trim }}", map[string]interface{}{"Foo": "   some text     \t"}, options.ExitWithError, "", "Trim test: some text", false},
		{"Round test: {{`{{`}} .Foo | round }}", map[string]interface{}{"Foo": "0.45"}, options.ExitWithError, "", "Round test: 0", false},
		{"Ceil test: {{`{{`}} .Foo | ceil }}", map[string]interface{}{"Foo": "0.45"}, options.ExitWithError, "", "Ceil test: 1", false},
		{"Floor test: {{`{{`}} .Foo | floor }}", map[string]interface{}{"Foo": "0.45"}, options.ExitWithError, "", "Floor test: 0", false},
		{"Dasherize test: {{`{{`}} .Foo | dasherize }}", map[string]interface{}{"Foo": "foo BAR baz!"}, options.ExitWithError, "", "Dasherize test: foo-bar-baz", false},
		{"Snake case test: {{`{{`}} .Foo | snakeCase }}", map[string]interface{}{"Foo": "foo BAR baz!"}, options.ExitWithError, "", "Snake case test: foo_bar_baz", false},
		{"Camel case test: {{`{{`}} .Foo | camelCase }}", map[string]interface{}{"Foo": "foo BAR baz!"}, options.ExitWithError, "", "Camel case test: FooBARBaz", false},
		{"Camel case lower test: {{`{{`}} .Foo | camelCaseLower }}", map[string]interface{}{"Foo": "foo BAR baz!"}, options.ExitWithError, "", "Camel case lower test: fooBARBaz", false},
		{"Plus test: {{`{{`}} plus .Foo .Bar }}", map[string]interface{}{"Foo": "5", "Bar": "3"}, options.ExitWithError, "", "Plus test: 8", false},
		{"Minus test: {{`{{`}} minus .Foo .Bar }}", map[string]interface{}{"Foo": "5", "Bar": "3"}, options.ExitWithError, "", "Minus test: 2", false},
		{"Times test: {{`{{`}} times .Foo .Bar }}", map[string]interface{}{"Foo": "5", "Bar": "3"}, options.ExitWithError, "", "Times test: 15", false},
		{"Divide test: {{`{{`}} divide .Foo .Bar | printf \"%1.5f\" }}", map[string]interface{}{"Foo": "5", "Bar": "3"}, options.ExitWithError, "", "Divide test: 1.66667", false},
		{"Mod test: {{`{{`}} mod .Foo .Bar }}", map[string]interface{}{"Foo": "5", "Bar": "3"}, options.ExitWithError, "", "Mod test: 2", false},
		{"Slice test: {{`{{`}} slice 0 5 1 }}", map[string]interface{}{}, options.ExitWithError, "", "Slice test: [0 1 2 3 4]", false},
		{"Keys test: {{`{{`}} keys .Map }}", map[string]interface{}{"Map": map[string]string{"key1": "value1", "key2": "value2", "key3": "value3"}}, options.ExitWithError, "", "Keys test: [key1 key2 key3]", false},
		{"Shell test: {{`{{`}} shell \"echo\" .Text }}", map[string]interface{}{"Text": "Hello, World"}, options.ExitWithError, "", "Shell test: Hello, World\n", runtime.GOOS == "windows"},
		{"Shell set env vars test: {{`{{`}} shell \"printenv\" \"FOO\" \"ENV:FOO=bar\" }}", map[string]interface{}{}, options.ExitWithError, "", "Shell set env vars test: bar\n", runtime.GOOS == "windows"},
		{"Shell read env vars test: {{`{{`}} env \"USER\" \"should-not-get-fallback\" }}", map[string]interface{}{}, options.ExitWithError, "", fmt.Sprintf("Shell read env vars test: %s", userFromEnvVar), runtime.GOOS == "windows"},
		{"Shell read env vars test, fallback: {{`{{`}} env \"not-a-valid-env-var\" \"should-get-fallback\" }}", map[string]interface{}{}, options.ExitWithError, "", "Shell read env vars test, fallback: should-get-fallback", false},
		{"Template folder test: {{`{{`}} templateFolder }}", map[string]interface{}{}, options.ExitWithError, "", "Template folder test: " + defaultTemplateDir, false},
		{"Output folder test: {{`{{`}} outputFolder }}", map[string]interface{}{}, options.ExitWithError, "", "Output folder test: " + defaultOutputDir, false},
		{"Filter chain test: {{`{{`}} .Foo | downcase | replaceAll \" \" \"\" }}", map[string]interface{}{"Foo": "foo BAR baz!"}, options.ExitWithError, "", "Filter chain test: foobarbaz!", false},
	}

	for _, testCase := range testCases {
		tt := testCase
		t.Run(tt.templateContents, func(t *testing.T) {
			if tt.skip {
				t.Skip("Skipping test because of skip flag")
				return
			}
			actualOutput, err := RenderTemplateFromString(pwd+"/template.txt", tt.templateContents, tt.variables, &options.BoilerplateOptions{TemplateFolder: "/templates", OutputFolder: defaultOutputDir, OnMissingKey: testCase.missingKeyAction})
			if tt.expectedErrorText == "" {
				assert.Nil(t, err, "template = %s, variables = %s, missingKeyAction = %s, err = %v", tt.templateContents, tt.variables, tt.missingKeyAction, err)
				assert.Equal(t, tt.expectedOutput, actualOutput, "template = %s, variables = %s, missingKeyAction = %s", tt.templateContents, tt.variables, tt.missingKeyAction)
			} else {
				if assert.NotNil(t, err, "template = %s, variables = %s, missingKeyAction = %s", tt.templateContents, tt.variables, tt.missingKeyAction) {
					assert.Contains(t, err.Error(), tt.expectedErrorText, "template = %s, variables = %s, missingKeyAction = %s", tt.templateContents, tt.variables, tt.missingKeyAction)

				}
			}
		})
	}
}
-- render/template_helpers.go --
package render

import (
	"bufio"
	"fmt"
	"io/ioutil"
	"math"
	"os"
	"path"
	"path/filepath"
	"reflect"
	"regexp"
	"sort"
	"strconv"
	"strings"
	"text/template"
	"unicode"

	"github.com/Masterminds/sprig/v3"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
	"gopkg.in/yaml.v2"
)

var SNIPPET_MARKER_REGEX = regexp.MustCompile("boilerplate-snippet:\\s*(.+?)(?:\\s|$)")

var WHITESPACE_REGEX = regexp.MustCompile("[[:space:]]+")

var PUNCTUATION_OR_WHITESPACE_REGEX = regexp.MustCompile("([[:space:]]|[[:punct:]])+")

var ENV_VAR_REGEX = regexp.MustCompile("^ENV:(.+?)=(.*)$")

const SHELL_DISABLED_PLACEHOLDER = "replace-me"

// This regex can be used to split CamelCase strings into "words". That is, given a string like FooBarBaz, you can use
// this regex to split it into an array ["Foo", "Bar", "Baz"]. It also handles lower camel case, which is the same as
// camel case, except it starts with a lower case word, such as fooBarBaz.
//
// To capture lowercase camel case, we just look for words that consist of lower case letters and digits at the start
// of the string. To capture all other camel case, we look for "words" that start with one or more consecutive upper
// case letters followed by one or more lower case letters or digits.
var CAMEL_CASE_REGEX = regexp.MustCompile(
	"(^([[:lower:]]|[[:digit:]])+)|" + // Handle lower camel case
		"([[:upper:]]*([[:lower:]]|[[:digit:]]|$)*)") // Handle normal camel case

// All boilerplate template helpers implement this signature. They get the path of the template they are rendering as
// the first arg, the Boilerplate Options as the second arg, and then any arguments the user passed when calling the
// helper.
type TemplateHelper func(templatePath string, opts *options.BoilerplateOptions, args ...string) (string, error)

// Create a map of custom template helpers exposed by boilerplate
func CreateTemplateHelpers(templatePath string, opts *options.BoilerplateOptions, tmpl *template.Template) template.FuncMap {
	sprigFuncs := sprig.FuncMap()
	// We rename a few sprig functions that overlap with boilerplate implementations. See DEPRECATED note on boilerplate
	// functions below for more details.
	sprigFuncs["listSlice"] = sprigFuncs["slice"]
	sprigFuncs["replaceAll"] = sprigFuncs["replace"]
	sprigFuncs["keysUnordered"] = sprigFuncs["keys"]
	sprigFuncs["readEnv"] = sprigFuncs["env"]
	sprigFuncs["roundFloat"] = sprigFuncs["round"]
	sprigFuncs["ceilFloat"] = sprigFuncs["ceil"]
	sprigFuncs["floorFloat"] = sprigFuncs["floor"]
	sprigFuncs["trimPrefixSprig"] = sprigFuncs["trimPrefix"]
	sprigFuncs["trimSuffixSprig"] = sprigFuncs["trimSuffix"]

	boilerplateFuncs := map[string]interface{}{
		"roundInt": wrapFloatToIntFunction(round),
		"ceilInt":  wrapFloatToFloatFunction(math.Ceil),
		"floorInt": wrapFloatToFloatFunction(math.Floor),

		"plus":   wrapFloatFloatToFloatFunction(func(arg1 float64, arg2 float64) float64 { return arg1 + arg2 }),
		"minus":  wrapFloatFloatToFloatFunction(func(arg1 float64, arg2 float64) float64 { return arg1 - arg2 }),
		"times":  wrapFloatFloatToFloatFunction(func(arg1 float64, arg2 float64) float64 { return arg1 * arg2 }),
		"divide": wrapFloatFloatToFloatFunction(func(arg1 float64, arg2 float64) float64 { return arg1 / arg2 }),

		"dasherize":             dasherize,
		"camelCaseLower":        camelCaseLower,
		"replaceOne":            func(old string, new string, str string) string { return strings.Replace(str, old, new, 1) },
		"trimPrefixBoilerplate": trimPrefix,
		"trimSuffixBoilerplate": trimSuffix,
		"toYaml":                toYaml,

		"numRange":   slice,
		"keysSorted": keys,

		"snippet":    wrapWithTemplatePath(templatePath, opts, snippet),
		"include":    wrapIncludeWithTemplatePath(templatePath, opts),
		"shell":      wrapWithTemplatePath(templatePath, opts, shell),
		"pathExists": util.PathExists,

		"templateIsDefined": wrapIsDefinedWithTemplate(tmpl),

		"templateFolder":        func() (string, error) { return filepath.Abs(opts.TemplateFolder) },
		"outputFolder":          func() (string, error) { return filepath.Abs(opts.OutputFolder) },
		"relPath":               relPath,
		"boilerplateConfigDeps": boilerplateConfigDeps(opts),
		"boilerplateConfigVars": boilerplateConfigVars(opts),
		"envWithDefault":        env,

		// DEPRECATIONS

		// These functions are exactly the same as their sprig counterpart
		"downcase":   strings.ToLower, // lower
		"upcase":     strings.ToUpper, // upper
		"capitalize": strings.Title,   // title
		"snakeCase":  snakeCase,       // snakecase
		"camelCase":  camelCase,       // camelcase

		// In sprig, trimPrefix and trimSuffix take the arguments in different orders so that you can use pipelines. For backwards compatibility, we
		// have:
		// - trimPrefix : The original boilerplate version of trimPrefix.
		// - trimPrefixSprig : The sprig version of trimPrefix.
		// - trimPrefixBoilerplate : Another name for the boilerplate version of trimPrefix.
		// Users need to upgrade usage of `trimPrefix` with `trimPrefixBoilerplate`. The same with `trimSuffix`.
		"trimPrefix": trimPrefix,
		"trimSuffix": trimSuffix,

		// In sprig, round supports arbitrary decimal place rounding. E.g {{`{{`}} round 123.5555 3 }} returns 123.556. For
		// backwards compatibility, we have:
		// - round : The original boilerplate round function that rounds to nearest int.
		// - roundFloat : The sprig version of round.
		// - roundInt : Another name for the boilerplate round function that doesn't overlap with sprig.
		// Users need to upgrade usage of `round` with `roundInt`.
		"round": wrapFloatToIntFunction(round),

		// In sprig, ceil and floor is functionally the same as the boilerplate versions, except they return floats as
		// opposed to ints. E.g {{`{{`}} ceil 1.1 }} returns 2.0. For backwards compatibility, we have:
		// - ceil : The original boilerplate ceil function that truncates.
		// - ceilFloat : The sprig version of ceil.
		// - ceilInt : Another name for the boilerplate version of ceil that doesn't overlap with sprig.
		// Users need to update usage of `ceil` with `ceilInt`.
		// Note that the same function naming applies with floor.
		"ceil":  wrapFloatToFloatFunction(math.Ceil),
		"floor": wrapFloatToFloatFunction(math.Floor),

		// In sprig, env does not support default values. For backwards compatibility, we have:
		// - env : The original boilerplate env function that supports default value if env doesn't exist.
		// - readEnv : The sprig version of env.
		// - envWithDefault : Another name for the boilerplate env function that doesn't overlap with sprig.
		// Users need to upgrade usage of `env` with `envWithDefault`.
		"env": env,

		// In sprig, keys is the unordered keys version. To get the sorted version, you use
		// {{`{{`}} keys $myDict | sortAlpha }}. For backwards compatibility, we have:
		// - keys : The original boilerplate keys function that returns the keys in sorted order.
		// - keysUnordered : The sprig version of keys.
		// - keysSorted : Another name for the boilerplate keys function that doesn't overlap with sprig.
		// Users need to upgrade usage of `keys` with `keysSorted`.
		"keys": keys,

		// In sprig, replace is replaceAll. For backwards compatibility, we have:
		// - replace : The original boilerplate replace function
		// - replaceAll : The sprig version of replace. Compatible with original boilerplate replaceAll.
		// - replaceOne : Another name for the boilerplate replace function that doesn't overlap with sprig.
		// Users need to upgrade usage of `replace` with `replaceOne`.
		"replace": func(old string, new string, str string) string { return strings.Replace(str, old, new, 1) },

		// In sprig, slice is the very useful anylist slice function, that takes a list and returns list[n:m].
		// For backwards compatibility, we have:
		// - slice : The original boilerplate slice function
		// - sliceList : The sprig version of slice
		// - numRange : Another name for the boilerplate slice function that doesn't overlap with sprig
		// Users need to upgrade usage of `slice` to `numRange`.
		"slice": slice,
	}

	funcs := map[string]interface{}{}
	for k, v := range sprigFuncs {
		funcs[k] = v
	}
	for k, v := range boilerplateFuncs {
		funcs[k] = v
	}
	return funcs
}

// When writing a template, it's natural to use a relative path, such as:
//
// {{`{{`}}snippet "../../foo/bar"}}
//
// However, this only works if boilerplate is called from the same folder as the template itself. To work around this
// issue, this function can be used to wrap boilerplate template helpers to make the path of the template itself
// available as the first argument and the BoilerplateOptions as the second argument. The helper can use that path to
// relativize other paths, if necessary.
func wrapWithTemplatePath(templatePath string, opts *options.BoilerplateOptions, helper TemplateHelper) func(...string) (string, error) {
	return func(args ...string) (string, error) {
		return helper(templatePath, opts, args...)
	}
}

// This works exactly like wrapWithTemplatePath, but it is adapted to the function args for the include helper function.
func wrapIncludeWithTemplatePath(templatePath string, opts *options.BoilerplateOptions) func(string, map[string]interface{}) (string, error) {
	return func(path string, varData map[string]interface{}) (string, error) {
		return include(templatePath, opts, path, varData)
	}
}

// wrapIsDefinedWithTemplate wraps templateIsDefined, passing in the current *Template to allow the
// function to introspect what templates have been defined
func wrapIsDefinedWithTemplate(tmpl *template.Template) func(string) bool {
	return func(name string) bool {
		return templateIsDefined(tmpl, name)
	}
}

// templateIsDefined determines whether a given template name has been defined or not, allowing
// boilerplate templates to conditionally include other templates.
func templateIsDefined(tmpl *template.Template, name string) bool {
	for _, templateName := range tmpl.Templates() {
		if templateName.Name() == name {
			return true
		}
	}
	return false
}

// This helper expects the following args:
//
// snippet <TEMPLATE_PATH> <PATH> [SNIPPET_NAME]
//
// It returns the contents of PATH, relative to TEMPLATE_PATH, as a string. If SNIPPET_NAME is specified, only the
// contents of that snippet with that name will be returned. A snippet is any text in the file surrounded by a line on
// each side of the format "boilerplate-snippet: NAME" (typically using the comment syntax for the language).
func snippet(templatePath string, opts *options.BoilerplateOptions, args ...string) (string, error) {
	switch len(args) {
	case 1:
		return readFile(templatePath, args[0])
	case 2:
		return readSnippetFromFile(templatePath, args[0], args[1])
	default:
		return "", errors.WithStackTrace(InvalidSnippetArguments(args))
	}
}

// This helper expects the following args:
//
// include <TEMPLATE_PATH> <PATH> <VARIABLES>
//
// This helper returns the contents of PATH, relative to TEMPLAT_PATH, but rendered through the boilerplate templating
// engine with the given variables.
func include(templatePath string, opts *options.BoilerplateOptions, path string, varData map[string]interface{}) (string, error) {
	templateContents, err := readFile(templatePath, path)
	if err != nil {
		return "", err
	}
	return RenderTemplateFromString(templatePath, templateContents, varData, opts)
}

// Returns the given filePath relative to the given templatePath. If filePath is already an absolute path, returns it
// unchanged.
//
// Example:
//
// pathRelativeToTemplate("/foo/bar/template-file.txt, "../src/code.java")
//   Returns: "/foo/src/code.java"
func PathRelativeToTemplate(templatePath string, filePath string) string {
	if path.IsAbs(filePath) {
		return filePath
	} else if util.IsDir(templatePath) {
		return filepath.Join(templatePath, filePath)
	} else {
		templateDir := filepath.Dir(templatePath)
		return filepath.Join(templateDir, filePath)
	}
}

// Returns the contents of the file at path, relative to templatePath, as a string
func readFile(templatePath, path string) (string, error) {
	relativePath := PathRelativeToTemplate(templatePath, path)
	bytes, err := ioutil.ReadFile(relativePath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	return string(bytes), nil
}

// Returns the contents of snippet snippetName from the file at path, relative to templatePath.
func readSnippetFromFile(templatePath string, path string, snippetName string) (string, error) {
	relativePath := PathRelativeToTemplate(templatePath, path)
	file, err := os.Open(relativePath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	defer file.Close()

	scanner := bufio.NewScanner(file)
	return readSnippetFromScanner(scanner, snippetName)
}

// Returns the content of snippet snippetName from the given scanner
func readSnippetFromScanner(scanner *bufio.Scanner, snippetName string) (string, error) {
	scanner.Split(bufio.ScanLines)

	snippetLines := []string{}
	inSnippet := false

	for scanner.Scan() {
		line := scanner.Text()
		foundSnippetName, isSnippet := extractSnippetName(line)
		if isSnippet && foundSnippetName == snippetName {
			if inSnippet {
				return strings.Join(snippetLines, "\n"), nil
			} else {
				inSnippet = true
			}
		} else if inSnippet {
			snippetLines = append(snippetLines, line)
		}
	}

	if inSnippet {
		return "", errors.WithStackTrace(SnippetNotTerminated(snippetName))
	} else {
		return "", errors.WithStackTrace(SnippetNotFound(snippetName))
	}
}

// Extract the snippet name from the line of text. A snippet is of the form "boilerplate-snippet: NAME". If no snippet
// name is found, return false for the second argument.
func extractSnippetName(line string) (string, bool) {
	match := SNIPPET_MARKER_REGEX.FindStringSubmatch(line)
	if len(match) == 2 {
		snippetName := strings.TrimSpace(match[1])
		return snippetName, snippetName != ""
	} else {
		return "", false
	}
}

// Wrap a function that uses float64 as input and output so it can take any number as input and return a float64 as
// output
func wrapFloatToFloatFunction(f func(float64) float64) func(interface{}) (float64, error) {
	return func(value interface{}) (float64, error) {
		valueAsFloat, err := toFloat64(value)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		return f(valueAsFloat), nil
	}
}

// Wrap a function that uses float64 as input and int as output so it can take any number as input and return an int as
// output
func wrapFloatToIntFunction(f func(float64) int) func(interface{}) (int, error) {
	return func(value interface{}) (int, error) {
		valueAsFloat, err := toFloat64(value)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		return f(valueAsFloat), nil
	}
}

// Wrap a function that takes two ints as input and returns an int as output so it can take any kind of number as input
// and return an int as output
func wrapIntIntToIntFunction(f func(int, int) int) func(interface{}, interface{}) (int, error) {
	return func(arg1 interface{}, arg2 interface{}) (int, error) {
		arg1AsInt, err := toInt(arg1)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		arg2AsInt, err := toInt(arg2)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		return f(arg1AsInt, arg2AsInt), nil

	}
}

// Wrap a function that takes two float64's as input, performs arithmetic on them, and returns another float64 as a
// function that can take two values of any number kind as input and return a float64 as output
func wrapFloatFloatToFloatFunction(f func(arg1 float64, arg2 float64) float64) func(interface{}, interface{}) (float64, error) {
	return func(arg1 interface{}, arg2 interface{}) (float64, error) {
		arg1AsFloat, err := toFloat64(arg1)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		arg2AsFloat, err := toFloat64(arg2)
		if err != nil {
			return 0, errors.WithStackTrace(err)
		}
		return f(arg1AsFloat, arg2AsFloat), nil

	}
}

// Convert the given value to a float64. Does a proper conversion if the underlying type is a number. For all other
// types, we first convert to a string, and then try to parse the result as a float64.
func toFloat64(value interface{}) (float64, error) {
	// Because Go is a shitty language, we have to call out each of the numeric types separately, even though the
	// behavior for almost all of them is identical. If we tried to do a case statement with multiple clauses
	// (separated by comma), then the variable v would be of type interface{} and we could not use float64(..) to
	// convert it.
	switch v := value.(type) {
	case int:
		return float64(v), nil
	case int8:
		return float64(v), nil
	case int16:
		return float64(v), nil
	case int32:
		return float64(v), nil
	case int64:
		return float64(v), nil
	case uint:
		return float64(v), nil
	case uint8:
		return float64(v), nil
	case uint16:
		return float64(v), nil
	case uint32:
		return float64(v), nil
	case uint64:
		return float64(v), nil
	case float32:
		return float64(v), nil
	case float64:
		return v, nil
	default:
		return strconv.ParseFloat(fmt.Sprintf("%v", v), 64)
	}
}

// Convert the given value to an int. Does a proper conversion if the underlying type is a number. For all other
// types, we first convert to a string, and then try to parse the result as a int.
func toInt(value interface{}) (int, error) {
	// Because Go is a shitty language, we have to call out each of the numeric types separately, even though the
	// behavior for almost all of them is identical. If we tried to do a case statement with multiple clauses
	// (separated by comma), then the variable v would be of type interface{} and we could not use int(..) to
	// convert it.
	switch v := value.(type) {
	case int:
		return v, nil
	case int8:
		return int(v), nil
	case int16:
		return int(v), nil
	case int32:
		return int(v), nil
	case int64:
		return int(v), nil
	case uint:
		return int(v), nil
	case uint8:
		return int(v), nil
	case uint16:
		return int(v), nil
	case uint32:
		return int(v), nil
	case uint64:
		return int(v), nil
	case float32:
		return int(v), nil
	case float64:
		return int(v), nil
	default:
		return strconv.Atoi(fmt.Sprintf("%v", v))
	}
}

// Go's math package does not include a round function. This is because Go is a shitty language. Many people complained
// in this issue: https://github.com/golang/go/issues/4594. However, it was closed as "wontfix". Note the half dozen
// attempts to implement this function, most of which are wrong. This seems to be the right solution:
func round(f float64) int {
	if math.Abs(f) < 0.5 {
		return 0
	}
	return int(f + math.Copysign(0.5, f))
}

// Convert a string to an all lowercase, dash-delimited string, dropping all other punctuation and whitespace. E.g.
// "foo BAR baz!" becomes "foo-bar-baz".
func dasherize(str string) string {
	return toDelimitedString(str, "-")
}

// Convert a string to an all lower case, underscore-delimited string, dropping all other punctuation and whitespace.
// E.g. "foo BAR baz!" becomes "foo_bar_baz".
func snakeCase(str string) string {
	return toDelimitedString(str, "_")
}

// Convert a string to camel case, dropping all punctuation and whitespace. E.g. "foo BAR baz!" becomes "FooBarBaz".
func camelCase(str string) string {
	// First, we strip any leading or trailing white space, underscores, or dashes
	trimmed := trimWhiteSpaceAndPunctuation(str)

	// Next, any time we find whitespace or punctuation repeated consecutively more than once, we replace
	// them with a single space.
	collapsed := collapseWhiteSpaceAndPunctuationToDelimiter(trimmed, " ")

	// Now we split on whitespace to find all the words in the string
	words := WHITESPACE_REGEX.Split(collapsed, -1)

	// Capitalize each word
	capitalized := []string{}
	for _, word := range words {
		capitalized = append(capitalized, strings.Title(word))
	}

	// Join everything back together into a string
	return strings.Join(capitalized, "")
}

// Convert a string to camel case where the first letter is lower case, dropping all punctuation and whitespace. E.g.
// "foo BAR baz!" becomes "fooBarBaz".
func camelCaseLower(str string) string {
	return lowerFirst(camelCase(str))
}

// Returns a copy of str with the first character converted to lower case. E.g. "FOO" becomes "fOO".
func lowerFirst(str string) string {
	if len(str) == 0 {
		return str
	}

	chars := []rune(str)
	chars[0] = unicode.ToLower(chars[0])
	return string(chars)
}

// This function converts a string to an all lower case string delimited with the given delimiter, dropping all other
// punctuation and whitespace. For example, "foo BAR baz" and the delimiter "-" would become "foo-bar-baz".
// TODO: handle all punctuation
func toDelimitedString(str string, delimiter string) string {
	// Although this function doesn't look terribly complicated, the reason why it's written this way,
	// unfortunately, isn't terribly obvious, so I'm going to use copious comments to try to build some intuition.

	// First, we strip any leading or trailing whitespace or punctuation
	trimmed := trimWhiteSpaceAndPunctuation(str)

	// Next, any time we find whitespace or punctuation repeated consecutively more than once, we replace
	// them with a single space. This space is really just being used as a placeholder between "words." In the next
	// step, these placeholders will be replaced with the delimiter.
	collapsed := collapseWhiteSpaceAndPunctuationToDelimiter(trimmed, " ")

	// The final step is to split the string into individual camel case "words" (see the comments on
	// CAMEL_CASE_REGEX for details on how it works) so that something like "FooBarBaz" becomes the array
	// ["Foo", "Bar", "Baz"]. We then combine all these words with the delimiter in between them ("Foo-Bar-Baz")
	// and convert the entire string to lower case ("foo-bar-baz").
	return strings.ToLower(strings.Join(CAMEL_CASE_REGEX.FindAllString(collapsed, -1), delimiter))
}

// Returns str with all leading and trailing whitespace and punctuation removed. E.g. "   foo!!!" becomes "foo".
func trimWhiteSpaceAndPunctuation(str string) string {
	return strings.TrimFunc(str, func(r rune) bool { return unicode.IsSpace(r) || unicode.IsPunct(r) })
}

// Returns str with all consecutive whitespace and punctuation in it collapsed to the given delimiter. E.g.
// "foo.....bar_____baz" with a delimiter "-" becomes "foo-bar-baz".
func collapseWhiteSpaceAndPunctuationToDelimiter(str string, delimiter string) string {
	return PUNCTUATION_OR_WHITESPACE_REGEX.ReplaceAllString(str, delimiter)
}

// Generate a slice from start (inclusive) to end (exclusive), incrementing by increment. For example, slice(0, 5, 1)
// returns [0, 1, 2, 3, 4].
func slice(start interface{}, end interface{}, increment interface{}) ([]int, error) {
	out := []int{}

	startAsInt, err := toInt(start)
	if err != nil {
		return out, errors.WithStackTrace(err)
	}

	endAsInt, err := toInt(end)
	if err != nil {
		return out, errors.WithStackTrace(err)
	}

	incrementAsInt, err := toInt(increment)
	if err != nil {
		return out, errors.WithStackTrace(err)
	}

	for i := startAsInt; i < endAsInt; i += incrementAsInt {
		out = append(out, i)
	}

	return out, nil
}

// Return the keys in the given map. This method always returns the keys in sorted order to provide a stable iteration
// order.
func keys(value interface{}) ([]string, error) {
	valueType := reflect.ValueOf(value)
	if valueType.Kind() != reflect.Map {
		return nil, errors.WithStackTrace(InvalidTypeForMethodArgument{"keys", "Map", valueType.Kind().String()})
	}

	out := []string{}

	for _, key := range valueType.MapKeys() {
		out = append(out, fmt.Sprintf("%v", key.Interface()))
	}

	sort.Strings(out)

	return out, nil
}

// Run the given shell command specified in args in the working dir specified by templatePath and return stdout as a
// string.
func shell(templatePath string, opts *options.BoilerplateOptions, rawArgs ...string) (string, error) {
	if opts.DisableShell {
		util.Logger.Printf("Shell helpers are disabled. Will not execute shell command '%v'. Returning placeholder value '%s' instead.", rawArgs, SHELL_DISABLED_PLACEHOLDER)
		return SHELL_DISABLED_PLACEHOLDER, nil
	}

	if len(rawArgs) == 0 {
		return "", errors.WithStackTrace(NoArgsPassedToShellHelper)
	}

	args, envVars := separateArgsAndEnvVars(rawArgs)
	return util.RunShellCommandAndGetOutput(filepath.Dir(templatePath), envVars, args[0], args[1:]...)
}

// To pass env vars to the shell helper, we use the format ENV:KEY=VALUE. This method goes through the given list of
// arguments and splits it into two lists: the list of cmd-line args and the list of env vars.
func separateArgsAndEnvVars(rawArgs []string) ([]string, []string) {
	args := []string{}
	envVars := []string{}

	for _, rawArg := range rawArgs {
		matches := ENV_VAR_REGEX.FindStringSubmatch(rawArg)
		if len(matches) == 3 {
			key := matches[1]
			value := matches[2]
			envVars = append(envVars, fmt.Sprintf("%s=%s", key, value))
		} else {
			args = append(args, rawArg)
		}
	}

	return args, envVars
}

// Returns str without the provided leading prefix string. If str doesn't start with prefix, str is returned unchanged.
func trimPrefix(str, prefix string) string {
	return strings.TrimPrefix(str, prefix)
}

// Returns str without the provided trailing suffix string. If str doesn't end with suffix, str is returned unchanged.
func trimSuffix(str, suffix string) string {
	return strings.TrimPrefix(str, suffix)
}

func toYaml(obj interface{}) (string, error) {
	yamlObj, err := yaml.Marshal(&obj)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	return string(yamlObj), nil
}

// Returns the relative path between the output folders of a "base" path and a "target" path.
func relPath(basePath, targetPath string) (string, error) {
	relPath, err := filepath.Rel(basePath, targetPath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	return relPath, nil
}

// Returns the value of the environment variable with the given name. If that variable is not set, return fallbackValue.
func env(name string, fallbackValue string) string {
	value := os.Getenv(name)
	if value == "" {
		return fallbackValue
	} else {
		return value
	}
}

// Find the value of the given property of the given Dependency.
func boilerplateConfigDeps(opts *options.BoilerplateOptions) func(string, string) (string, error) {
	return func(name string, property string) (string, error) {
		deps := opts.Vars["BoilerplateConfigDeps"].(map[string]variables.Dependency)
		dep := deps[name]

		if dep.Name == "" {
			return "", fmt.Errorf(`The dependency "%s" was not found.`, name)
		}

		r := reflect.ValueOf(dep)
		f := reflect.Indirect(r).FieldByName(property)
		return f.String(), nil
	}
}

// Find the value of the given property of the given Variable.
func boilerplateConfigVars(opts *options.BoilerplateOptions) func(string, string) (string, error) {
	return func(name string, property string) (string, error) {
		vars := opts.Vars["BoilerplateConfigVars"].(map[string]variables.Variable)
		myVar := vars[name]

		if myVar.Name() == "" {
			return "", fmt.Errorf(`The variable "%s" was not found.`, name)
		}

		r := reflect.ValueOf(myVar)
		f := reflect.Indirect(r).FieldByName(property)
		return f.String(), nil
	}
}

// Custom errors

type SnippetNotFound string

func (snippetName SnippetNotFound) Error() string {
	return fmt.Sprintf("Could not find a snippet named %s", string(snippetName))
}

type SnippetNotTerminated string

func (snippetName SnippetNotTerminated) Error() string {
	return fmt.Sprintf("Snippet %s has an opening boilerplate-snippet marker, but not a closing one", string(snippetName))
}

type InvalidSnippetArguments []string

func (args InvalidSnippetArguments) Error() string {
	return fmt.Sprintf("The snippet helper expects the following args: snippet <TEMPLATE_PATH> <PATH> [SNIPPET_NAME]. Instead, got args: %s", []string(args))
}

var NoArgsPassedToShellHelper = fmt.Errorf("The shell helper requires at least one argument")

type InvalidTypeForMethodArgument struct {
	MethodName   string
	ExpectedType string
	ActualType   string
}

func (err InvalidTypeForMethodArgument) Error() string {
	return fmt.Sprintf("Method %s expects type %s, but got %s", err.MethodName, err.ExpectedType, err.ActualType)
}
-- render/template_helpers_test.go --
package render

import (
	"bufio"
	"bytes"
	"fmt"
	"path/filepath"
	"reflect"
	"runtime"
	"testing"
	"text/template"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestExtractSnippetName(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		line            string
		containsSnippet bool
		snippetName     string
	}{
		{"", false, ""},
		{"foo", false, ""},
		{"boilerplate", false, ""},
		{"boilerplate-snippet", false, ""},
		{"boilerplate-snippet:", false, ""},
		{"boilerplate-snippet: ", false, ""},
		{"boilerplate-snippet: foo", true, "foo"},
		{"boilerplate-snippet:foo", true, "foo"},
		{"boilerplate-snippet:\t\tfoo        ", true, "foo"},
		{"<!-- boilerplate-snippet: foo -->", true, "foo"},
		{"// boilerplate-snippet: foo", true, "foo"},
		{"/* boilerplate-snippet: foo */", true, "foo"},
		{"boilerplate-snippet: foo bar", true, "foo"},
		{"boilerplate-snippet:foo-bar-baz", true, "foo-bar-baz"},
	}

	for _, testCase := range testCases {
		snippetName, containsSnippet := extractSnippetName(testCase.line)
		assert.Equal(t, testCase.containsSnippet, containsSnippet)
		assert.Equal(t, testCase.snippetName, snippetName)
	}
}

const MULTILINE_SNIPPET_NOT_TERMINATED = `
foo
boilerplate-snippet: foo
bar blah
boilerplate-snippet: bar
`

const BODY_TEXT_ONE_LINE = "line1"

const BODY_TEXT_MULTILINE = `
line1
line2
line3
`

var FULL_FILE_ONE_LINE_SNIPPET = fmt.Sprintf(
	`
boilerplate-snippet: foo
%s
boilerplate-snippet: foo
`, BODY_TEXT_ONE_LINE)

var FULL_FILE_MULTILINE_SNIPPET = fmt.Sprintf(
	`
boilerplate-snippet: foo
%s
boilerplate-snippet: foo
`, BODY_TEXT_MULTILINE)

var FULL_FILE_MULTILINE_SNIPPET_IN_HTML_COMMENTS = fmt.Sprintf(
	`
<!-- boilerplate-snippet: foo -->
%s
<-- boilerplate-snippet: foo -->
`, BODY_TEXT_MULTILINE)

var PARTIAL_FILE_MULTILINE_SNIPPET_IN_C_COMMENTS = fmt.Sprintf(
	`
other text
this should be ignored

// boilerplate-snippet: foo
%s
// boilerplate-snippet: foo

this should also
be completely ignored
`, BODY_TEXT_MULTILINE)

var PARTIAL_FILE_ONE_LINE_SNIPPET_IN_MISMATCHED_COMMENTS = fmt.Sprintf(
	`
other text
this should be ignored

// boilerplate-snippet: foo
%s
/*boilerplate-snippet:foo */

this should also
be completely ignored
`, BODY_TEXT_ONE_LINE)

var PARTIAL_FILE_MUTLIPLE_SNIPPETS = fmt.Sprintf(
	`
other text
this should be ignored

boilerplate-snippet: bar
this should be ignored
boilerplate-snippet: bar

boilerplate-snippet: foo
%s
boilerplate-snippet: foo

boilerplate-snippet: baz
this should also
be completely ignored
boilerplate-snippet: baz
`, BODY_TEXT_ONE_LINE)

var PARTIAL_FILE_EMBEDDED_SNIPPETS = fmt.Sprintf(
	`
other text
this should be ignored

boilerplate-snippet: bar
bar

boilerplate-snippet: foo
%s
boilerplate-snippet: foo

blah
boilerplate-snippet: bar

boilerplate-snippet: baz
this should also
be completely ignored
boilerplate-snippet: baz
`, BODY_TEXT_ONE_LINE)

func TestReadSnippetFromScanner(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		text                string
		snippetName         string
		expectedErr         error
		expectedSnippetText string
	}{
		{"", "foo", SnippetNotFound("foo"), ""},
		{"abcdef", "foo", SnippetNotFound("foo"), ""},
		{"boilerplate-snippet: bar", "foo", SnippetNotFound("foo"), ""},
		{"boilerplate-snippet: foo", "foo", SnippetNotTerminated("foo"), ""},
		{MULTILINE_SNIPPET_NOT_TERMINATED, "foo", SnippetNotTerminated("foo"), ""},
		{FULL_FILE_ONE_LINE_SNIPPET, "foo", nil, BODY_TEXT_ONE_LINE},
		{FULL_FILE_MULTILINE_SNIPPET, "foo", nil, BODY_TEXT_MULTILINE},
		{FULL_FILE_MULTILINE_SNIPPET_IN_HTML_COMMENTS, "foo", nil, BODY_TEXT_MULTILINE},
		{PARTIAL_FILE_MULTILINE_SNIPPET_IN_C_COMMENTS, "foo", nil, BODY_TEXT_MULTILINE},
		{PARTIAL_FILE_ONE_LINE_SNIPPET_IN_MISMATCHED_COMMENTS, "foo", nil, BODY_TEXT_ONE_LINE},
		{PARTIAL_FILE_MUTLIPLE_SNIPPETS, "foo", nil, BODY_TEXT_ONE_LINE},
		{PARTIAL_FILE_EMBEDDED_SNIPPETS, "foo", nil, BODY_TEXT_ONE_LINE},
	}

	for _, testCase := range testCases {
		scanner := bufio.NewScanner(bytes.NewBufferString(testCase.text))
		snippetText, err := readSnippetFromScanner(scanner, testCase.snippetName)

		if testCase.expectedErr == nil {
			assert.Nil(t, err)
			assert.Equal(t, testCase.expectedSnippetText, snippetText)
		} else {
			assert.NotNil(t, err)
			assert.True(t, errors.IsError(err, testCase.expectedErr), "Expected %s error but got %s", reflect.TypeOf(testCase.expectedErr), reflect.TypeOf(err))
		}
	}
}

func TestPathRelativeToTemplate(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		templatePath string
		path         string
		expected     string
		skip         bool
	}{
		{"/template.txt", ".", filepath.ToSlash("/"), false},
		{"/foo/bar/template.txt", ".", filepath.ToSlash("/foo/bar"), false},
		{"/foo/bar/template.txt", "..", filepath.ToSlash("/foo"), false},
		{"/foo/bar/template.txt", "../..", filepath.ToSlash("/"), false},
		{"/foo/bar/template.txt", "../../bar/baz", filepath.ToSlash("/bar/baz"), false},
		{"/foo/bar/template.txt", "foo", filepath.ToSlash("/foo/bar/foo"), false},
		{"/foo/bar/template.txt", "./foo", filepath.ToSlash("/foo/bar/foo"), false},
		{"/foo/bar/template.txt", "/foo", filepath.ToSlash("/foo"), false},
		{"/foo/bar/template.txt", "/foo/bar/baz", filepath.ToSlash("/foo/bar/baz"), false},
		{"/usr/bin", "../foo", "/usr/foo", runtime.GOOS == "windows"}, // Note, we are testing with a real file path here to ensure directories are handled correctly
	}

	for _, testCase := range testCases {
		tt := testCase
		t.Run(tt.templatePath, func(t *testing.T) {
			if tt.skip {
				t.Skip()
				return
			}
			actual := PathRelativeToTemplate(tt.templatePath, tt.path)
			assert.Equal(t, tt.expected, filepath.ToSlash(actual))
		})
	}
}

func TestWrapWithTemplatePath(t *testing.T) {
	t.Parallel()

	expectedPath := "/foo/bar/template.txt"
	expectedOpts := &options.BoilerplateOptions{NonInteractive: true}

	var actualPath string
	var actualOpts *options.BoilerplateOptions

	wrappedFunc := wrapWithTemplatePath(expectedPath, expectedOpts, func(templatePath string, opts *options.BoilerplateOptions, args ...string) (string, error) {
		actualPath = templatePath
		actualOpts = opts

		return templatePath, nil
	})

	returnedPath, err := wrappedFunc()
	assert.Nil(t, err)
	assert.Equal(t, expectedPath, returnedPath)
	assert.Equal(t, expectedPath, actualPath)
	assert.Equal(t, expectedOpts, actualOpts)
}

func TestDasherize(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    string
		expected string
	}{
		{"", ""},
		{"     ", ""},
		{"foo", "foo"},
		{"FOO", "foo"},
		{" \t  foo   \t", "foo"},
		{"FooBarBaz", "foo-bar-baz"},
		{"Fo", "fo"},
		{"fooID", "foo-id"},
		{"FoB", "fo-b"},
		{"oFo", "o-fo"},
		{"FoBa", "fo-ba"},
		{"oFoBa", "o-fo-ba"},
		{"oFoB", "o-fo-b"},
		{"Foo123B1234Baz1234", "foo123-b1234-baz1234"},
		{"Foo_Bar_Baz", "foo-bar-baz"},
		{"FooIDbarBaz", "foo-idbar-baz"},
		{"FOOIDbarBaz", "fooidbar-baz"},
		{" A B C ", "a-b-c"},
		{"foo bar baz", "foo-bar-baz"},
		{"foo \t \tbar   baz \t", "foo-bar-baz"},
		{"foo_bar_baz", "foo-bar-baz"},
		{"_foo_bar_baz_", "foo-bar-baz"},
		{"foo-bar-baz", "foo-bar-baz"},
		{"foo--bar----baz", "foo-bar-baz"},
		{"foo__bar____baz", "foo-bar-baz"},
		{" Foo Bar Baz ", "foo-bar-baz"},
		{" Foo Bar_BazBlah ", "foo-bar-baz-blah"},
		{" Foo.Bar.Baz", "foo-bar-baz"},
		{"#@!Foo@#$@$Bar>>>>>Baz", "foo-bar-baz"},
	}

	for _, testCase := range testCases {
		actual := dasherize(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling dasherize on '%s', expected '%s', but got '%s'", testCase.input, testCase.expected, actual)
	}
}

func TestSnakeCase(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    string
		expected string
	}{
		{"", ""},
		{"     ", ""},
		{"foo", "foo"},
		{"FOO", "foo"},
		{" \t  foo   \t", "foo"},
		{"FooBarBaz", "foo_bar_baz"},
		{"Fo", "fo"},
		{"fooID", "foo_id"},
		{"FoB", "fo_b"},
		{"oFo", "o_fo"},
		{"FoBa", "fo_ba"},
		{"oFoBa", "o_fo_ba"},
		{"oFoB", "o_fo_b"},
		{"Foo123B1234Baz1234", "foo123_b1234_baz1234"},
		{"Foo_Bar_Baz", "foo_bar_baz"},
		{"FooIDbarBaz", "foo_idbar_baz"},
		{"FOOIDbarBaz", "fooidbar_baz"},
		{" A B C ", "a_b_c"},
		{"foo bar baz", "foo_bar_baz"},
		{"foo \t \tbar   baz \t", "foo_bar_baz"},
		{"foo_bar_baz", "foo_bar_baz"},
		{"_foo_bar_baz_", "foo_bar_baz"},
		{"foo-bar-baz", "foo_bar_baz"},
		{"foo--bar----baz", "foo_bar_baz"},
		{"foo__bar____baz", "foo_bar_baz"},
		{" Foo Bar Baz ", "foo_bar_baz"},
		{" Foo Bar_BazBlah ", "foo_bar_baz_blah"},
		{" Foo.Bar.Baz", "foo_bar_baz"},
		{"#@!Foo@#$@$Bar>>>>>Baz", "foo_bar_baz"},
	}

	for _, testCase := range testCases {
		actual := snakeCase(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling snakeCase on '%s', expected '%s', but got '%s'", testCase.input, testCase.expected, actual)
	}
}

func TestCamelCase(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    string
		expected string
	}{
		{"", ""},
		{"     ", ""},
		{"foo", "Foo"},
		{"FOO", "FOO"},
		{" \t  foo   \t", "Foo"},
		{"FooBarBaz", "FooBarBaz"},
		{"Fo", "Fo"},
		{"fooID", "FooID"},
		{"FoB", "FoB"},
		{"oFo", "OFo"},
		{"FoBa", "FoBa"},
		{"oFoBa", "OFoBa"},
		{"oFoB", "OFoB"},
		{"Foo123B1234Baz1234", "Foo123B1234Baz1234"},
		{"Foo_Bar_Baz", "FooBarBaz"},
		{"FooIDbarBaz", "FooIDbarBaz"},
		{"FOOIDbarBaz", "FOOIDbarBaz"},
		{" A B C ", "ABC"},
		{"foo bar baz", "FooBarBaz"},
		{"foo \t \tbar   baz \t", "FooBarBaz"},
		{"foo_bar_baz", "FooBarBaz"},
		{"_foo_bar_baz_", "FooBarBaz"},
		{"foo-bar-baz", "FooBarBaz"},
		{"foo--bar----baz", "FooBarBaz"},
		{"foo__bar____baz", "FooBarBaz"},
		{" Foo Bar Baz ", "FooBarBaz"},
		{" Foo Bar_BazBlah ", "FooBarBazBlah"},
		{" Foo.Bar.Baz", "FooBarBaz"},
		{"#@!Foo@#$@$Bar>>>>>Baz", "FooBarBaz"},
	}

	for _, testCase := range testCases {
		actual := camelCase(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling camelCase on '%s', expected '%s', but got '%s'", testCase.input, testCase.expected, actual)
	}
}

func TestCamelCaseLower(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    string
		expected string
	}{
		{"", ""},
		{"     ", ""},
		{"foo", "foo"},
		{"FOO", "fOO"},
		{" \t  foo   \t", "foo"},
		{"FooBarBaz", "fooBarBaz"},
		{"Fo", "fo"},
		{"fooID", "fooID"},
		{"FoB", "foB"},
		{"oFo", "oFo"},
		{"FoBa", "foBa"},
		{"oFoBa", "oFoBa"},
		{"oFoB", "oFoB"},
		{"Foo123B1234Baz1234", "foo123B1234Baz1234"},
		{"Foo_Bar_Baz", "fooBarBaz"},
		{"FooIDbarBaz", "fooIDbarBaz"},
		{"FOOIDbarBaz", "fOOIDbarBaz"},
		{" A B C ", "aBC"},
		{"foo bar baz", "fooBarBaz"},
		{"foo \t \tbar   baz \t", "fooBarBaz"},
		{"foo_bar_baz", "fooBarBaz"},
		{"_foo_bar_baz_", "fooBarBaz"},
		{"foo-bar-baz", "fooBarBaz"},
		{"foo--bar----baz", "fooBarBaz"},
		{"foo__bar____baz", "fooBarBaz"},
		{" Foo Bar Baz ", "fooBarBaz"},
		{" Foo Bar_BazBlah ", "fooBarBazBlah"},
		{" Foo.Bar.Baz", "fooBarBaz"},
		{"#@!Foo@#$@$Bar>>>>>Baz", "fooBarBaz"},
	}

	for _, testCase := range testCases {
		actual := camelCaseLower(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling camelCaseLower on '%s', expected '%s', but got '%s'", testCase.input, testCase.expected, actual)
	}
}

func TestLowerFirst(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    string
		expected string
	}{
		{"", ""},
		{"     ", "     "},
		{"foo", "foo"},
		{"Foo", "foo"},
		{"FOO", "fOO"},
		{"Здравейте", "здравейте"},
	}

	for _, testCase := range testCases {
		actual := lowerFirst(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling lowerFirst on '%s', expected '%s', but got '%s'", testCase.input, testCase.expected, actual)
	}
}

func TestShellSuccess(t *testing.T) {
	t.Parallel()
	var output string
	var err error
	var eol string
	if runtime.GOOS == "windows" {
		eol = "\r\n"
		output, err = shell(".", &options.BoilerplateOptions{NonInteractive: true}, "cmd.exe", "/C", "echo", "hi")
	} else {
		eol = "\n"
		output, err = shell(".", &options.BoilerplateOptions{NonInteractive: true}, "echo", "hi")
	}
	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, "hi"+eol, output)
}

func TestShellError(t *testing.T) {
	t.Parallel()

	_, err := shell(".", &options.BoilerplateOptions{NonInteractive: true}, "not-a-real-command")
	if assert.NotNil(t, err) {
		if runtime.GOOS == "windows" {
			assert.Contains(t, err.Error(), "executable file not found in %PATH%", "Unexpected error message: %s", err.Error())
		} else {
			assert.Contains(t, err.Error(), "executable file not found in $PATH", "Unexpected error message: %s", err.Error())
		}

	}
}

func TestShellDisabled(t *testing.T) {
	t.Parallel()

	output, err := shell(".", &options.BoilerplateOptions{NonInteractive: true, DisableShell: true}, "echo", "hi")
	assert.Nil(t, err, "Unexpected error: %v", err)
	assert.Equal(t, SHELL_DISABLED_PLACEHOLDER, output)
}

// TestTemplateIsDefined tests that the templateIsDefined function correctly
// identifies templates that have been added to the parse tree
func TestTemplateIsDefined(t *testing.T) {
	t.Parallel()

	fooTemplate := "This is foo."
	tmplFoo, err := template.New("foo").Parse(fooTemplate)
	require.NoError(t, err)

	f := wrapIsDefinedWithTemplate(tmplFoo)

	assert.True(t, f("foo"))
	assert.False(t, f("bar"))

	barTemplate := "This is bar."
	tmplBar, err := template.New("bar").Parse(barTemplate)
	require.NoError(t, err)

	tmplFoo.AddParseTree("bar", tmplBar.Tree)

	assert.True(t, f("bar"))
}

// TestToYaml tests that a given value can be correctly encoded to YAML
func TestToYaml(t *testing.T) {
	t.Parallel()
	testCases := []struct {
		input    interface{}
		expected string
	}{
		{nil, "null\n"},
		{"", "\"\"\n"},
		{map[string]interface{}{"key": "val"}, "key: val\n"},
		{map[string][]interface{}{"Key": {1, 2, 3}}, "Key:\n- 1\n- 2\n- 3\n"},
	}
	for _, testCase := range testCases {
		actual, err := toYaml(testCase.input)
		require.NoError(t, err)
		assert.Equal(t, testCase.expected, actual)
	}
}

// I cannot believe I have to write my own function and test code for rounding numbers in Go. FML.
func TestRound(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input    float64
		expected int
	}{
		{0, 0},
		{0.0, 0},
		{0.25, 0},
		{0.49, 0},
		{0.4999999999999, 0},
		{0.5, 1},
		{0.50000000000000001, 1},
		{0.75, 1},
		{0.999999999999999, 1},
		{1, 1},
		{1.0, 1},
		{151515151.234234234, 151515151},
	}

	for _, testCase := range testCases {
		actual := round(testCase.input)
		assert.Equal(t, testCase.expected, actual, "When calling round on %f, expected %d, but got %d", testCase.input, testCase.expected, actual)
	}
}
-- templates/engines_processor.go --
package templates

import (
	"path/filepath"

	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
)

type ProcessedEngine struct {
	// List of paths relative to template folder that should be skipped
	EvaluatedPaths []string

	// The template engine to use.
	TemplateEngine variables.TemplateEngineType
}

// processEngines will take the engines list and process them in the current boilerplate context. This is primarily
// rendering the glob expression for the Path attribute.
func processEngines(
	engines []variables.Engine,
	opts *options.BoilerplateOptions,
	variables map[string]interface{},
) ([]ProcessedEngine, error) {
	output := []ProcessedEngine{}
	for _, engine := range engines {
		matchedPaths, err := renderGlobPath(opts, engine.Path, variables)
		if err != nil {
			return nil, err
		}
		debugLogForMatchedPaths(engine.Path, matchedPaths, "Engine", "Path")

		processedEngine := ProcessedEngine{
			EvaluatedPaths: matchedPaths,
			TemplateEngine: engine.TemplateEngine,
		}
		output = append(output, processedEngine)
	}
	return output, nil
}

// determineTemplateEngine returns the template engine that should be used based on the engine directive and the path of
// the template file to process.
func determineTemplateEngine(processedEngines []ProcessedEngine, path string) variables.TemplateEngineType {
	// Canonicalize paths for os portability.
	canonicalPath := filepath.ToSlash(path)

	// If the path matches any of the engine directives, return the engine specified by that directive. Otherwise,
	// return the default template engine.
	for _, engine := range processedEngines {
		if util.ListContains(canonicalPath, engine.EvaluatedPaths) {
			return engine.TemplateEngine
		}
	}
	return variables.DefaultTemplateEngine

}
-- templates/skip_files_processor.go --
package templates

import (
	"path/filepath"

	zglob "github.com/mattn/go-zglob"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/render"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
)

type ProcessedSkipFile struct {
	// List of paths relative to template folder that should be skipped
	EvaluatedPaths []string

	// List of paths relative to template folder that should not be skipped
	EvaluatedNotPaths []string

	// Whether or not to skip the files if the paths match. This is the boilerplate rendered value of the if attribute
	// of a given skip file.
	RenderedSkipIf bool
}

// processSkipFiles will take the skip_files list and process them in the current boilerplate context. This includes:
// - Rendering the glob expression for the Path attribute.
// - Rendering the if attribute using the provided variables.
func processSkipFiles(skipFiles []variables.SkipFile, opts *options.BoilerplateOptions, variables map[string]interface{}) ([]ProcessedSkipFile, error) {
	output := []ProcessedSkipFile{}
	for _, skipFile := range skipFiles {
		matchedPaths, err := renderGlobPath(opts, skipFile.Path, variables)
		if err != nil {
			return nil, errors.WithStackTrace(err)
		}
		if skipFile.Path != "" {
			debugLogForMatchedPaths(skipFile.Path, matchedPaths, "SkipFile", "Path")
		}

		matchedNotPaths, err := renderGlobPath(opts, skipFile.NotPath, variables)
		if err != nil {
			return nil, errors.WithStackTrace(err)
		}
		if skipFile.NotPath != "" {
			debugLogForMatchedPaths(skipFile.NotPath, matchedNotPaths, "SkipFile", "NotPath")
		}

		renderedSkipIf, err := skipFileIfCondition(skipFile, opts, variables)
		if err != nil {
			return nil, err
		}

		processedSkipFile := ProcessedSkipFile{
			EvaluatedPaths:    matchedPaths,
			EvaluatedNotPaths: matchedNotPaths,
			RenderedSkipIf:    renderedSkipIf,
		}
		output = append(output, processedSkipFile)
	}
	return output, nil
}

// Return true if the if parameter of the given SkipFile evaluates to a "true" value
func skipFileIfCondition(skipFile variables.SkipFile, opts *options.BoilerplateOptions, variables map[string]interface{}) (bool, error) {
	// If the "if" attribute of skip_files was not specified, then default to true.
	if skipFile.If == "" {
		return true, nil
	}

	rendered, err := render.RenderTemplateFromString(opts.TemplateFolder, skipFile.If, variables, opts)
	if err != nil {
		return false, err
	}

	// TODO: logger-debug - switch to debug
	if skipFile.Path != "" {
		util.Logger.Printf("If attribute for SkipFile Path %s evaluated to '%s'", skipFile.Path, rendered)
	} else if skipFile.NotPath != "" {
		util.Logger.Printf("If attribute for SkipFile NotPath %s evaluated to '%s'", skipFile.NotPath, rendered)
	} else {
		util.Logger.Printf("WARN: SkipFile has no path or not_path!")
	}
	return rendered == "true", nil
}

func debugLogForMatchedPaths(sourcePath string, paths []string, directiveName string, directiveAttribute string) {
	// TODO: logger-debug - switch to debug
	util.Logger.Printf("Following paths were picked up by %s attribute for %s (%s):", directiveAttribute, directiveName, sourcePath)
	for _, path := range paths {
		util.Logger.Printf("\t- %s", path)
	}
}

// renderGlobPath will render the glob of the given path in the template folder and return the list of matched paths.
// Note that the paths will be canonicalized to unix slashes regardless of OS.
func renderGlobPath(opts *options.BoilerplateOptions, path string, variables map[string]interface{}) ([]string, error) {
	if path == "" {
		return []string{}, nil
	}

	rendered, err := render.RenderTemplateFromString(opts.TemplateFolder, path, variables, opts)
	if err != nil {
		return nil, err
	}

	globPath := filepath.Join(opts.TemplateFolder, rendered)
	rawMatchedPaths, err := zglob.Glob(globPath)
	if err != nil {
		// TODO: logger-debug - switch to debug
		util.Logger.Printf("ERROR: could not glob %s", globPath)
		return nil, errors.WithStackTrace(err)
	}
	// Canonicalize the matched paths prior to storage
	matchedPaths := []string{}
	for _, path := range rawMatchedPaths {
		matchedPaths = append(matchedPaths, filepath.ToSlash(path))
	}
	return matchedPaths, nil
}
-- templates/template_processor.go --
package templates

import (
	"fmt"
	"net/url"
	"os"
	"path"
	"path/filepath"
	"strings"

	"github.com/gruntwork-io/go-commons/collections"

	"github.com/gruntwork-io/boilerplate/config"
	"github.com/gruntwork-io/boilerplate/errors"
	getter_helper "github.com/gruntwork-io/boilerplate/getter-helper"
	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/render"
	"github.com/gruntwork-io/boilerplate/util"
	"github.com/gruntwork-io/boilerplate/variables"
)

// The name of the variable that contains the current value of the loop in each iteration of for_each
const eachVarName = "__each__"

// Process the boilerplate template specified in the given options and use the existing variables. This function will
// download remote templates to a temporary working directory, which is cleaned up at the end of the function. This
// function will load any missing variables (either from command line options or by prompting the user), execute all the
// dependent boilerplate templates, and then execute this template. Note that we pass in rootOptions so that template
// dependencies can inspect properties of the root template.
func ProcessTemplate(options, rootOpts *options.BoilerplateOptions, thisDep variables.Dependency) error {
	// If TemplateFolder is already set, use that directly as it is a local template. Otherwise, download to a temporary
	// working directory.
	if options.TemplateFolder == "" {
		workingDir, templateFolder, err := getter_helper.DownloadTemplatesToTemporaryFolder(options.TemplateUrl)
		defer func() {
			util.Logger.Printf("Cleaning up working directory.")
			os.RemoveAll(workingDir)
		}()
		if err != nil {
			return err
		}

		// Set the TemplateFolder of the options to the download dir
		options.TemplateFolder = templateFolder
	}

	rootBoilerplateConfig, err := config.LoadBoilerplateConfig(rootOpts)
	if err != nil {
		return err
	}
	if err := config.EnforceRequiredVersion(rootBoilerplateConfig); err != nil {
		return err
	}

	boilerplateConfig, err := config.LoadBoilerplateConfig(options)
	if err != nil {
		return err
	}
	if err := config.EnforceRequiredVersion(boilerplateConfig); err != nil {
		return err
	}

	vars, err := config.GetVariables(options, boilerplateConfig, rootBoilerplateConfig, thisDep)
	if err != nil {
		return err
	}

	err = os.MkdirAll(options.OutputFolder, 0777)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	err = processHooks(boilerplateConfig.Hooks.BeforeHooks, options, vars)
	if err != nil {
		return err
	}

	err = processDependencies(boilerplateConfig.Dependencies, options, boilerplateConfig.GetVariablesMap(), vars)
	if err != nil {
		return err
	}

	partials, err := processPartials(boilerplateConfig.Partials, options, vars)
	if err != nil {
		return err
	}

	err = processTemplateFolder(boilerplateConfig, options, vars, partials)
	if err != nil {
		return err
	}

	err = processHooks(boilerplateConfig.Hooks.AfterHooks, options, vars)
	if err != nil {
		return err
	}

	return nil
}

func processPartials(partials []string, opts *options.BoilerplateOptions, vars map[string]interface{}) ([]string, error) {
	var renderedPartials []string
	for _, partial := range partials {
		renderedPartial, err := render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), partial, vars, opts)
		if err != nil {
			return []string{}, err
		}
		renderedPartials = append(renderedPartials, renderedPartial)
	}
	return renderedPartials, nil
}

// Process the given list of hooks, which are scripts that should be executed at the command-line
func processHooks(hooks []variables.Hook, opts *options.BoilerplateOptions, vars map[string]interface{}) error {
	for _, hook := range hooks {
		err := processHook(hook, opts, vars)
		if err != nil {
			return err
		}
	}

	return nil
}

// Process the given hook, which is a script that should be execute at the command-line
func processHook(hook variables.Hook, opts *options.BoilerplateOptions, vars map[string]interface{}) error {
	skip, err := shouldSkipHook(hook, opts, vars)
	if err != nil {
		return err
	}
	if skip {
		util.Logger.Printf("Skipping hook with command '%s'", hook.Command)
		return nil
	}

	cmd, err := render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), hook.Command, vars, opts)
	if err != nil {
		return err
	}

	args := []string{}
	for _, arg := range hook.Args {
		renderedArg, err := render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), arg, vars, opts)
		if err != nil {
			return err
		}
		args = append(args, renderedArg)
	}

	envVars := []string{}
	for key, value := range hook.Env {
		renderedKey, err := render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), key, vars, opts)
		if err != nil {
			return err
		}

		renderedValue, err := render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), value, vars, opts)
		if err != nil {
			return err
		}

		envVars = append(envVars, fmt.Sprintf("%s=%s", renderedKey, renderedValue))
	}

	workingDir := opts.TemplateFolder
	if hook.WorkingDir != "" {
		workingDir, err = render.RenderTemplateFromString(config.BoilerplateConfigPath(opts.TemplateFolder), hook.WorkingDir, vars, opts)
		if err != nil {
			return err
		}
	}

	return util.RunShellCommand(workingDir, envVars, cmd, args...)
}

// Return true if the "skip" condition of this hook evaluates to true
func shouldSkipHook(hook variables.Hook, opts *options.BoilerplateOptions, vars map[string]interface{}) (bool, error) {
	if opts.DisableHooks {
		util.Logger.Printf("Hooks are disabled")
		return true, nil
	}

	if hook.Skip == "" {
		return false, nil
	}

	rendered, err := render.RenderTemplateFromString(opts.TemplateFolder, hook.Skip, vars, opts)
	if err != nil {
		return false, err
	}

	util.Logger.Printf("Skip attribute for hook with command '%s' evaluated to '%s'", hook.Command, rendered)
	return rendered == "true", nil
}

// Execute the boilerplate templates in the given list of dependencies
func processDependencies(
	dependencies []variables.Dependency,
	opts *options.BoilerplateOptions,
	variablesInConfig map[string]variables.Variable,
	variables map[string]interface{},
) error {
	for _, dependency := range dependencies {
		err := processDependency(dependency, opts, variablesInConfig, variables)
		if err != nil {
			return err
		}
	}

	return nil
}

// Execute the boilerplate template in the given dependency
func processDependency(
	dependency variables.Dependency,
	opts *options.BoilerplateOptions,
	variablesInConfig map[string]variables.Variable,
	originalVars map[string]interface{},
) error {
	shouldProcess, err := shouldProcessDependency(dependency, opts, originalVars)
	if err != nil {
		return err
	}

	if shouldProcess {
		doProcess := func(updatedVars map[string]interface{}) error {
			dependencyOptions, err := cloneOptionsForDependency(dependency, opts, variablesInConfig, updatedVars)
			if err != nil {
				return err
			}

			util.Logger.Printf("Processing dependency %s, with template folder %s and output folder %s", dependency.Name, dependencyOptions.TemplateFolder, dependencyOptions.OutputFolder)
			return ProcessTemplate(dependencyOptions, opts, dependency)
		}

		forEach := dependency.ForEach
		if len(dependency.ForEachReference) > 0 {
			value, err := variables.UnmarshalListOfStrings(originalVars, dependency.ForEachReference)
			if err != nil {
				return err
			}

			forEach = value
		}

		if len(forEach) > 0 {
			for _, item := range forEach {
				updatedVars := collections.MergeMaps(originalVars, map[string]interface{}{eachVarName: item})
				if err := doProcess(updatedVars); err != nil {
					return err
				}
			}

			return nil
		} else {
			return doProcess(originalVars)
		}
	} else {
		util.Logger.Printf("Skipping dependency %s", dependency.Name)
		return nil
	}
}

// Clone the given options for use when rendering the given dependency. The dependency will get the same options as
// the original passed in, except for the template folder, output folder, and command-line vars.
func cloneOptionsForDependency(
	dependency variables.Dependency,
	originalOpts *options.BoilerplateOptions,
	variablesInConfig map[string]variables.Variable,
	variables map[string]interface{},
) (*options.BoilerplateOptions, error) {
	renderedTemplateUrl, err := render.RenderTemplateFromString(originalOpts.TemplateFolder, dependency.TemplateUrl, variables, originalOpts)
	if err != nil {
		return nil, err
	}
	renderedOutputFolder, err := render.RenderTemplateFromString(originalOpts.TemplateFolder, dependency.OutputFolder, variables, originalOpts)
	if err != nil {
		return nil, err
	}

	templateUrl, templateFolder, err := options.DetermineTemplateConfig(renderedTemplateUrl)
	if err != nil {
		return nil, err
	}
	// If local, make sure to return relative path in context of original template folder
	if templateFolder != "" {
		templateFolder = render.PathRelativeToTemplate(originalOpts.TemplateFolder, renderedTemplateUrl)
	}

	// Output folder should be local path relative to original output folder, or absolute path
	outputFolder := render.PathRelativeToTemplate(originalOpts.OutputFolder, renderedOutputFolder)

	renderedVarFiles := []string{}
	for _, varFilePath := range dependency.VarFiles {
		renderedVarFilePath, err := render.RenderTemplateFromString(originalOpts.TemplateFolder, varFilePath, variables, originalOpts)
		if err != nil {
			return nil, err
		}
		renderedVarFiles = append(renderedVarFiles, renderedVarFilePath)
	}

	vars, err := cloneVariablesForDependency(originalOpts, dependency, variablesInConfig, variables, renderedVarFiles)
	if err != nil {
		return nil, err
	}

	return &options.BoilerplateOptions{
		TemplateUrl:             templateUrl,
		TemplateFolder:          templateFolder,
		OutputFolder:            outputFolder,
		NonInteractive:          originalOpts.NonInteractive,
		Vars:                    vars,
		OnMissingKey:            originalOpts.OnMissingKey,
		OnMissingConfig:         originalOpts.OnMissingConfig,
		DisableHooks:            originalOpts.DisableHooks,
		DisableShell:            originalOpts.DisableShell,
		DisableDependencyPrompt: originalOpts.DisableDependencyPrompt,
	}, nil
}

// Clone the given variables for use when rendering the given dependency.  The dependency will get the same variables
// as the originals passed in, filtered to variable names that do not include a dependency or explicitly are for the
// given dependency.
// This function implements the following order of preference for rendering variables:
//   - Variables set on the CLI (originalVariables) directly for the dependency (DEPENDENCY.VARNAME), unless
//     DontInheritVariables is set.
//   - Variables defined from VarFiles set on the dependency.
//   - Variables defaults set on the dependency.
func cloneVariablesForDependency(
	opts *options.BoilerplateOptions,
	dependency variables.Dependency,
	variablesInConfig map[string]variables.Variable,
	originalVariables map[string]interface{},
	renderedVarFiles []string,
) (map[string]interface{}, error) {
	// Clone the opts so that we attempt to get the value for the variable, and we can error on any variable that is set
	// on a dependency and the value can't be computed.
	dependencyOpts := &options.BoilerplateOptions{
		NonInteractive: true,
		OnMissingKey:   options.ExitWithError,

		TemplateUrl:             opts.TemplateUrl,
		TemplateFolder:          opts.TemplateFolder,
		OutputFolder:            opts.OutputFolder,
		Vars:                    opts.Vars,
		OnMissingConfig:         opts.OnMissingConfig,
		DisableHooks:            opts.DisableHooks,
		DisableShell:            opts.DisableShell,
		DisableDependencyPrompt: opts.DisableDependencyPrompt,
	}

	// Start with the original variables. Note that it doesn't matter that originalVariables contains both CLI and
	// non-CLI passed variables, as the CLI passed variables will be handled at the end to re-override back, ensuring
	// they have the highest precedence. Ideally we can handle non-CLI and CLI passed variables separately, but that
	// requires a larger refactoring at the top level so for now, we do this hacky approach allowing the dependency
	// defined variables to override both CLI and non-CLI passed variables, and then add back in the CLI passed
	// variables.
	// We also filter out any dependency namespaced variables, as those are only passed in from the CLI and will be
	// handled later.
	newVariables := map[string]interface{}{}
	if !dependency.DontInheritVariables {
		for key, value := range originalVariables {
			dependencyName, _ := variables.SplitIntoDependencyNameAndVariableName(key)
			if dependencyName == "" {
				newVariables[key] = value
			}
		}
	}

	varFileVars, err := variables.ParseVars(nil, renderedVarFiles)
	if err != nil {
		return nil, err
	}

	currentVariables := util.MergeMaps(originalVariables, varFileVars)
	for _, variable := range dependency.Variables {
		varValue, err := config.GetValueForVariable(
			variable,
			variablesInConfig,
			currentVariables,
			dependencyOpts,
			0,
		)
		if err != nil {
			return nil, err
		}
		newVariables[variable.Name()] = varValue
	}

	newVariables = util.MergeMaps(newVariables, varFileVars)

	if dependency.DontInheritVariables {
		return newVariables, nil
	}

	// Now handle the CLI passed variables. Note that we handle dependency namespaced values separately, as they have
	// the highest precedence.
	// First loop handling all variables that are not dependency namespaced, or that are dependency namespaced but are
	// not targeting this dependency.
	for key, value := range opts.Vars {
		dependencyName, _ := variables.SplitIntoDependencyNameAndVariableName(key)
		if dependencyName != dependency.Name {
			newVariables[key] = value
		}
	}
	// Second loop handling all variables that are dependency namespaced, overriding those that are not dependency
	// namespaced.
	for key, value := range opts.Vars {
		dependencyName, originalName := variables.SplitIntoDependencyNameAndVariableName(key)
		if dependencyName == dependency.Name {
			newVariables[originalName] = value
		}
	}

	return newVariables, nil
}

// Prompt the user to verify if the given dependency should be executed and return true if they confirm. If
// options.NonInteractive or options.DisableDependencyPrompt are set to true, this function always returns true.
func shouldProcessDependency(dependency variables.Dependency, opts *options.BoilerplateOptions, variables map[string]interface{}) (bool, error) {
	shouldSkip, err := shouldSkipDependency(dependency, opts, variables)
	if err != nil {
		return false, err
	}
	if shouldSkip {
		return false, nil
	}

	if opts.NonInteractive || opts.DisableDependencyPrompt {
		return true, nil
	}

	return util.PromptUserForYesNo(fmt.Sprintf("This boilerplate template has a dependency! Run boilerplate on dependency %s with template folder %s and output folder %s?", dependency.Name, dependency.TemplateUrl, dependency.OutputFolder))
}

// Return true if the skip parameter of the given dependency evaluates to a "true" value
func shouldSkipDependency(dependency variables.Dependency, opts *options.BoilerplateOptions, variables map[string]interface{}) (bool, error) {
	if dependency.Skip == "" {
		return false, nil
	}

	rendered, err := render.RenderTemplateFromString(opts.TemplateFolder, dependency.Skip, variables, opts)
	if err != nil {
		return false, err
	}

	util.Logger.Printf("Skip attribute for dependency %s evaluated to '%s'", dependency.Name, rendered)
	return rendered == "true", nil
}

// Copy all the files and folders in templateFolder to outputFolder, passing text files through the Go template engine
// with the given set of variables as the data.
func processTemplateFolder(
	config *config.BoilerplateConfig,
	opts *options.BoilerplateOptions,
	variables map[string]interface{},
	partials []string,
) error {
	util.Logger.Printf("Processing templates in %s and outputting generated files to %s", opts.TemplateFolder, opts.OutputFolder)

	// Process and render skip files and engines before walking so we only do the rendering operation once.
	processedSkipFiles, err := processSkipFiles(config.SkipFiles, opts, variables)
	if err != nil {
		return err
	}
	processedEngines, err := processEngines(config.Engines, opts, variables)
	if err != nil {
		return err
	}

	return filepath.Walk(opts.TemplateFolder, func(path string, info os.FileInfo, err error) error {
		path = filepath.ToSlash(path)
		if shouldSkipPath(path, opts, processedSkipFiles) {
			util.Logger.Printf("Skipping %s", path)
			return nil
		} else if util.IsDir(path) {
			return createOutputDir(path, opts, variables)
		} else {
			engine := determineTemplateEngine(processedEngines, path)
			return processFile(path, opts, variables, partials, engine)
		}
	})
}

// Copy the given path, which is in the folder templateFolder, to the outputFolder, passing it through the Go template
// engine with the given set of variables as the data if it's a text file.
func processFile(
	path string,
	opts *options.BoilerplateOptions,
	variables map[string]interface{},
	partials []string,
	engine variables.TemplateEngineType,
) error {
	isText, err := util.IsTextFile(path)
	if err != nil {
		return err
	}

	if isText {
		return processTemplate(path, opts, variables, partials, engine)
	} else {
		return copyFile(path, opts, variables)
	}
}

// Create the given directory, which is in templateFolder, in the given outputFolder
func createOutputDir(dir string, opts *options.BoilerplateOptions, variables map[string]interface{}) error {
	destination, err := outPath(dir, opts, variables)
	if err != nil {
		return err
	}

	util.Logger.Printf("Creating folder %s", destination)
	return os.MkdirAll(destination, 0777)
}

// Compute the path where the given file, which is in templateFolder, should be copied in outputFolder. If the file
// path contains boilerplate syntax, use the given options and variables to render it to determine the final output
// path.
func outPath(file string, opts *options.BoilerplateOptions, variables map[string]interface{}) (string, error) {
	templateFolderAbsPath, err := filepath.Abs(opts.TemplateFolder)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	// | is an illegal filename char in Windows, so we also support urlencoded chars in the path. To support this, we
	// first urldecode the file before passing it through.
	urlDecodedFile, err := url.QueryUnescape(file)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	interpolatedFilePath, err := render.RenderTemplateFromString(file, urlDecodedFile, variables, opts)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	fileAbsPath, err := filepath.Abs(interpolatedFilePath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	relPath, err := filepath.Rel(templateFolderAbsPath, fileAbsPath)
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	return path.Join(opts.OutputFolder, relPath), nil
}

// Copy the given file, which is in options.TemplateFolder, to options.OutputFolder
func copyFile(file string, opts *options.BoilerplateOptions, variables map[string]interface{}) error {
	destination, err := outPath(file, opts, variables)
	if err != nil {
		return err
	}

	util.Logger.Printf("Copying %s to %s", file, destination)
	return util.CopyFile(file, destination)
}

// Run the template at templatePath, which is in templateFolder, through the Go template engine with the given
// variables as data and write the result to outputFolder
func processTemplate(
	templatePath string,
	opts *options.BoilerplateOptions,
	vars map[string]interface{},
	partials []string,
	engine variables.TemplateEngineType,
) error {
	destination, err := outPath(templatePath, opts, vars)
	if err != nil {
		return err
	}

	var out string
	switch engine {
	case variables.GoTemplate:
		out, err = render.RenderTemplateWithPartials(templatePath, partials, vars, opts)
		if err != nil {
			return err
		}
	case variables.Jsonnet:
		out, err = render.RenderJsonnetTemplate(templatePath, vars, opts)
		if err != nil {
			return err
		}
		// Strip the jsonnet extension from the destination, if it exists.
		destination = strings.TrimSuffix(destination, ".jsonnet")
	}

	return util.WriteFileWithSamePermissions(templatePath, destination, []byte(out))
}

// Return true if this is a path that should not be copied
func shouldSkipPath(path string, opts *options.BoilerplateOptions, processedSkipFiles []ProcessedSkipFile) bool {
	// Canonicalize paths for os portability.
	canonicalPath := filepath.ToSlash(path)
	canonicalTemplateFolder := filepath.ToSlash(opts.TemplateFolder)
	canonicalBoilerplateConfigPath := filepath.ToSlash(config.BoilerplateConfigPath(opts.TemplateFolder))

	// First check if the path is a part of the the skipFile list. To handle skipping:
	// - If the path matches with any entry in the skip files list and the if condition evaluates to true, skip the file.
	// - If the path does NOT match with any entry in the not_path list, and the if condition evaluates to true, skip
	//   the file.
	// NOTE: the composition for these directives are different. For `path` attribute, the composition is an `any`
	// operation. That is, if the path matches any one of the `path` attributes, then the file is skipped.
	// OTOH, for `not_path` attribute, the composition is an `all` operation. The file must not match ALL of the
	// `not_path` attributes to be skipped, but only if any one of the skip files has not_path attribute set.
	if pathInAnySkipPath(canonicalPath, processedSkipFiles) {
		return true
	}
	// not in any == not in all
	if anyNotPathEffective(processedSkipFiles) && pathInAnySkipNotPath(canonicalPath, processedSkipFiles) == false {
		return true
	}

	// Then check if the path is the template folder root or the boilerplate config.
	return canonicalPath == canonicalTemplateFolder || canonicalPath == canonicalBoilerplateConfigPath
}

// pathInAnySkipPath returns true if the given path matches any one of the path attributes in the skip file list.
func pathInAnySkipPath(canonicalPath string, skipFileList []ProcessedSkipFile) bool {
	for _, skipFile := range skipFileList {
		inSkipList := util.ListContains(canonicalPath, skipFile.EvaluatedPaths)
		if skipFile.RenderedSkipIf && inSkipList {
			return true
		}
	}
	return false
}

// anyNotPathEffective returns true if any skip file has a NotPath attribute defined and the rendered if condition is
// true.
func anyNotPathEffective(skipFileList []ProcessedSkipFile) bool {
	for _, skipFile := range skipFileList {
		if skipFile.RenderedSkipIf && len(skipFile.EvaluatedNotPaths) > 0 {
			return true
		}
	}
	return false
}

// pathInAnySkipNotPath returns true if the given path matches any one of the not_path attributes in the skip file list.
// Note that unlike pathInAnySkipPath, this also does a directory check, where the directory is considered in the
// not_path list. This is because the `not_path` list is an include list as opposed to a skip list, so we must copy over
// the directory to copy over the exact file.
func pathInAnySkipNotPath(canonicalPath string, skipFileList []ProcessedSkipFile) bool {
	for _, skipFile := range skipFileList {
		if skipFile.RenderedSkipIf == false || len(skipFile.EvaluatedNotPaths) == 0 {
			continue
		}

		inSkipNotPathList := util.ListContains(canonicalPath, skipFile.EvaluatedNotPaths)
		if inSkipNotPathList {
			return true
		}

		for _, path := range skipFile.EvaluatedNotPaths {
			if strings.HasPrefix(path, canonicalPath+"/") {
				return true
			}
		}
	}
	return false
}
-- templates/template_processor_test.go --
package templates

import (
	"os"
	"path/filepath"
	"testing"

	"github.com/gruntwork-io/boilerplate/options"
	"github.com/gruntwork-io/boilerplate/variables"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

func TestOutPath(t *testing.T) {
	t.Parallel()

	pwd, err := os.Getwd()
	assert.NoError(t, err)

	testCases := []struct {
		file           string
		templateFolder string
		outputFolder   string
		variables      map[string]interface{}
		expected       string
	}{
		{"template-folder/foo.txt", "template-folder", "output-folder", map[string]interface{}{}, "output-folder/foo.txt"},
		{"foo/bar/template-folder/foo.txt", "foo/bar/template-folder", "output-folder", map[string]interface{}{}, "output-folder/foo.txt"},
		{"template-folder/foo.txt", pwd + "/template-folder", "output-folder", map[string]interface{}{}, "output-folder/foo.txt"},
		{"template-folder/foo/bar/baz.txt", pwd + "/template-folder", "output-folder", map[string]interface{}{}, "output-folder/foo/bar/baz.txt"},
		{"template-folder/{{`{{`}}.Foo}}.txt", pwd + "/template-folder", "output-folder", map[string]interface{}{"Foo": "foo"}, "output-folder/foo.txt"},
		{"template-folder/{{`{{`}}.Foo | dasherize}}.txt", pwd + "/template-folder", "output-folder", map[string]interface{}{"Foo": "Foo Bar Baz"}, "output-folder/foo-bar-baz.txt"},
	}

	for _, testCase := range testCases {
		opts := options.BoilerplateOptions{
			TemplateFolder:  testCase.templateFolder,
			OutputFolder:    testCase.outputFolder,
			NonInteractive:  true,
			OnMissingKey:    options.ExitWithError,
			OnMissingConfig: options.Exit,
		}
		actual, err := outPath(testCase.file, &opts, testCase.variables)
		assert.NoError(t, err, "Got unexpected error (file = %s, templateFolder = %s, outputFolder = %s, and variables = %s): %v", testCase.file, testCase.templateFolder, testCase.outputFolder, testCase.variables, err)
		assert.Equal(t, filepath.FromSlash(testCase.expected), filepath.FromSlash(actual), "(file = %s, templateFolder = %s, outputFolder = %s, and variables = %s)", testCase.file, testCase.templateFolder, testCase.outputFolder, testCase.variables)
	}
}

func TestCloneOptionsForDependency(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		dependency   variables.Dependency
		opts         options.BoilerplateOptions
		variables    map[string]interface{}
		expectedOpts options.BoilerplateOptions
	}{
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			options.BoilerplateOptions{TemplateFolder: "/template/path/", OutputFolder: "/output/path/", NonInteractive: true, Vars: map[string]interface{}{}, OnMissingKey: options.ExitWithError},
			map[string]interface{}{},
			options.BoilerplateOptions{TemplateUrl: "../dep1", TemplateFolder: filepath.FromSlash("/template/dep1"), OutputFolder: filepath.FromSlash("/output/out1"), NonInteractive: true, Vars: map[string]interface{}{}, OnMissingKey: options.ExitWithError},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			options.BoilerplateOptions{TemplateFolder: "/template/path/", OutputFolder: "/output/path/", DisableDependencyPrompt: true, Vars: map[string]interface{}{}, OnMissingKey: options.ExitWithError},
			map[string]interface{}{},
			options.BoilerplateOptions{TemplateUrl: "../dep1", TemplateFolder: filepath.FromSlash("/template/dep1"), OutputFolder: filepath.FromSlash("/output/out1"), DisableDependencyPrompt: true, Vars: map[string]interface{}{}, OnMissingKey: options.ExitWithError},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			options.BoilerplateOptions{TemplateFolder: "/template/path/", OutputFolder: "/output/path/", NonInteractive: false, Vars: map[string]interface{}{"foo": "bar"}, OnMissingKey: options.Invalid},
			map[string]interface{}{"baz": "blah"},
			options.BoilerplateOptions{TemplateUrl: "../dep1", TemplateFolder: filepath.FromSlash("/template/dep1"), OutputFolder: filepath.FromSlash("/output/out1"), NonInteractive: false, Vars: map[string]interface{}{"foo": "bar", "baz": "blah"}, OnMissingKey: options.Invalid},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "{{`{{`}} .foo }}", OutputFolder: "{{`{{`}} .baz }}"},
			options.BoilerplateOptions{TemplateFolder: "/template/path/", OutputFolder: "/output/path/", NonInteractive: false, Vars: map[string]interface{}{}, OnMissingKey: options.ExitWithError},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
			options.BoilerplateOptions{TemplateUrl: "bar", TemplateFolder: filepath.FromSlash("/template/path/bar"), OutputFolder: filepath.FromSlash("/output/path/blah"), NonInteractive: false, Vars: map[string]interface{}{"foo": "bar", "baz": "blah"}, OnMissingKey: options.ExitWithError},
		},
	}

	for _, testCase := range testCases {
		tt := testCase
		t.Run(tt.dependency.Name, func(t *testing.T) {
			actualOptions, err := cloneOptionsForDependency(tt.dependency, &tt.opts, nil, tt.variables)
			assert.NoError(t, err, "Dependency: %s", tt.dependency)
			assert.Equal(t, tt.expectedOpts, *actualOptions, "Dependency: %s", tt.dependency)
		})

	}
}

func TestCloneVariablesForDependency(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		dependency        variables.Dependency
		variables         map[string]interface{}
		optsVars          map[string]interface{}
		expectedVariables map[string]interface{}
	}{
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			map[string]interface{}{},
			map[string]interface{}{},
			map[string]interface{}{},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
			map[string]interface{}{},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
			map[string]interface{}{"dep1.abc": "should-modify-name", "dep2.def": "should-copy-unmodified"},
			map[string]interface{}{"foo": "bar", "baz": "blah", "abc": "should-modify-name", "dep2.def": "should-copy-unmodified"},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1"},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
			map[string]interface{}{"dep1.abc": "should-modify-name", "dep2.def": "should-copy-unmodified", "abc": "should-be-overwritten-by-dep1.abc"},
			map[string]interface{}{"foo": "bar", "baz": "blah", "abc": "should-modify-name", "dep2.def": "should-copy-unmodified"},
		},
		{
			variables.Dependency{Name: "dep1", TemplateUrl: "../dep1", OutputFolder: "../out1", DontInheritVariables: true},
			map[string]interface{}{"foo": "bar", "baz": "blah"},
			map[string]interface{}{"dep1.abc": "should-modify-name", "dep2.def": "should-copy-unmodified"},
			map[string]interface{}{},
		},
	}

	for _, testCase := range testCases {
		tt := testCase
		t.Run(tt.dependency.Name, func(t *testing.T) {
			opts := &options.BoilerplateOptions{
				TemplateFolder: "/template/path/",
				OutputFolder:   "/output/path/",
				NonInteractive: true,
				Vars:           tt.optsVars,
			}
			actualVariables, err := cloneVariablesForDependency(opts, tt.dependency, nil, tt.variables, nil)
			require.NoError(t, err)
			assert.Equal(t, tt.expectedVariables, actualVariables, "Dependency: %s", tt.dependency)
		})

	}
}
-- util/collections.go --
package util

import "fmt"

// Merge all the maps into one. Sadly, Go has no generics, so this is only defined for string to interface maps.
func MergeMaps(maps ...map[string]any) map[string]any {
	out := map[string]any{}

	for _, currMap := range maps {
		for key, value := range currMap {
			out[key] = value
		}
	}

	return out
}

// Return true if the given list of strings (haystack) contains the given string (needle)
func ListContains(needle string, haystack []string) bool {
	for _, str := range haystack {
		if needle == str {
			return true
		}
	}

	return false
}

// Convert a generic list to a list of strings
func ToStringList(genericList []any) []string {
	stringList := []string{}

	for _, value := range genericList {
		stringList = append(stringList, ToString(value))
	}

	return stringList
}

// Convert a generic map to a map from string to string
func ToStringMap(genericMap map[any]any) map[string]string {
	stringMap := map[string]string{}

	for key, value := range genericMap {
		stringMap[ToString(key)] = ToString(value)
	}

	return stringMap
}

// Convert a generic map to a map from string to interface
func ToStringToGenericMap(genericMap map[any]any) map[string]any {
	stringToGenericMap := map[string]any{}

	for key, value := range genericMap {
		stringToGenericMap[ToString(key)] = value
	}

	return stringToGenericMap
}

// Convert a single value to its string representation
func ToString(value any) string {
	return fmt.Sprintf("%v", value)
}
-- util/file.go --
package util

import (
	"fmt"
	"github.com/gabriel-vasile/mimetype"
	"github.com/gruntwork-io/boilerplate/errors"
	"io/ioutil"
	"os"
	"os/exec"
	"path/filepath"
)

const textMimeType = "text/plain"

// Return true if the path exists
func PathExists(path string) bool {
	_, err := os.Stat(path)
	return err == nil
}

// Return true if the path points to a directory
func IsDir(path string) bool {
	fileInfo, err := os.Stat(path)
	return err == nil && fileInfo.IsDir()
}

// IsTextFile - usage of mimetype library to identify if the file is binary or text.
func IsTextFile(path string) (bool, error) {
	if !PathExists(path) {
		return false, NoSuchFile(path)
	}
	// consider empty file as binary file
	fileInfo, err := os.Stat(path)
	if err != nil {
		return false, errors.WithStackTrace(err)
	}
	if fileInfo.Size() == 0 {
		return false, nil
	}

	detectedMIME, err := mimetype.DetectFile(path)
	if err != nil {
		return false, errors.WithStackTrace(err)
	}
	for mtype := detectedMIME; mtype != nil; mtype = mtype.Parent() {
		if mtype.Is(textMimeType) {
			return true, nil
		}
	}
	return false, nil
}

// Return true if the OS has the given command installed
func CommandInstalled(command string) bool {
	_, err := exec.LookPath(command)
	return err == nil
}

// Run the given command return its stdout and stderr as a string
func RunCommandAndGetOutput(command string, args ...string) (string, error) {
	cmd := exec.Command(command, args...)

	bytes, err := cmd.Output()
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	return string(bytes), nil
}

// Copy a file from source to destination
func CopyFile(source string, destination string) error {
	contents, err := ioutil.ReadFile(source)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	return WriteFileWithSamePermissions(source, destination, contents)
}

// Write a file to the given destination with the given contents using the same permissions as the file at source
func WriteFileWithSamePermissions(source string, destination string, contents []byte) error {
	fileInfo, err := os.Stat(source)
	if err != nil {
		return errors.WithStackTrace(err)
	}

	return ioutil.WriteFile(destination, contents, fileInfo.Mode())
}

// Copy all the files and folders in srcFolder to targetFolder.
func CopyFolder(srcFolder string, targetFolder string) error {
	return filepath.Walk(srcFolder, func(path string, info os.FileInfo, err error) error {
		relPath, err := filepath.Rel(srcFolder, path)
		if err != nil {
			return err
		}

		if IsDir(path) {
			return os.MkdirAll(filepath.Join(targetFolder, relPath), 0755)
		} else {
			return CopyFile(path, filepath.Join(targetFolder, relPath))
		}
	})
}

// custom error types

type NoSuchFile string

func (path NoSuchFile) Error() string {
	return fmt.Sprintf("File %s does not exist", string(path))
}
-- util/file_test.go --
package util

import (
	"fmt"
	"reflect"
	"testing"

	"github.com/stretchr/testify/assert"

	"github.com/gruntwork-io/boilerplate/errors"
)

func TestIsTextFile(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		file   string
		isText bool
	}{
		{"binary-file.jpg", false},
		{"binary-file.png", false},
		{"binary-file.pdf", false},
		{"binary-file.zip", false},
		{"binary-file", false},
		{"empty-file", false},
		{"text-file.html", true},
		{"text-file.js", true},
		{"text-file.txt", true},
		{"text-file.md", true},
		{"text-file.tf", true},
		{"json-file.json", true},
		{"yaml-file.yaml", true},
		{"file-go.go", true},
		{"file-java.java", true},
		{"file-xml.xml", true},
		{"file-hcl.hcl", true},
	}

	for _, testCase := range testCases {
		testCase := testCase
		t.Run(testCase.file, func(t *testing.T) {
			t.Parallel()
			actual, err := IsTextFile(fmt.Sprintf("../test-fixtures/util-test/is-text-file/%s", testCase.file))

			assert.Nil(t, err)
			assert.Equal(t, testCase.isText, actual, "Incorrect classification for %s", testCase.file)
		})
	}
}

func TestIsTextFileInvalidPath(t *testing.T) {
	t.Parallel()

	_, err := IsTextFile("invalid-path")
	assert.NotNil(t, err)
	assert.True(t, errors.IsError(err, NoSuchFile("invalid-path")), "Expected NoSuchFile error but got %s", reflect.TypeOf(err))
}
-- util/logger.go --
package util

import (
	"log"
	"os"
)

// A simple logger we can use to get consistent log formatting through out the app
var Logger = log.New(os.Stdout, "[boilerplate] ", log.LstdFlags)
-- util/marshal.go --
package util

import (
	"fmt"

	"github.com/gruntwork-io/boilerplate/errors"
	"gopkg.in/yaml.v2"
)

// MarshalListOfObjectsToYAML will marshal the list of objects to yaml by calling MarshalYAML on every item in the list
// and return the results as a list. This is useful when building a custom YAML marshaler.
func MarshalListOfObjectsToYAML(inputList []interface{}) ([]interface{}, error) {
	output := []interface{}{}
	for _, item := range inputList {
		itemAsMarshaler, hasType := item.(yaml.Marshaler)
		if hasType == false {
			return nil, errors.WithStackTrace(UnmarshalableObjectErr{item})
		}
		yaml, err := itemAsMarshaler.MarshalYAML()
		if err != nil {
			return nil, errors.WithStackTrace(ObjectMarshalingErr{item, err})
		}
		output = append(output, yaml)
	}
	return output, nil
}

// Custom errors

// ObjectMarshalingErr is returned when there was an error marshaling the given object to yaml.
type ObjectMarshalingErr struct {
	object        interface{}
	underlyingErr error
}

func (err ObjectMarshalingErr) Error() string {
	return fmt.Sprintf("Error marshaling %v to YAML: %s", err.object, err.underlyingErr)
}

// UnmarshalableObjectErr is returned when the given object does not implement Marshaler interface.
type UnmarshalableObjectErr struct {
	object interface{}
}

func (err UnmarshalableObjectErr) Error() string {
	return fmt.Sprintf("Can not marshal %v to YAML", err.object)
}
-- util/prompt.go --
package util

import (
	"bufio"
	"fmt"
	"os"
	"strings"

	"github.com/fatih/color"
	"github.com/inancgumus/screen"

	"github.com/gruntwork-io/boilerplate/errors"
)

var BRIGHT_GREEN = color.New(color.FgHiGreen, color.Bold)

// Prompt the user for text in the CLI. Returns the text entered by the user.
func PromptUserForInput(prompt string) (string, error) {
	BRIGHT_GREEN.Print(fmt.Sprintf("%s: ", prompt))
	reader := bufio.NewReader(os.Stdin)

	text, err := reader.ReadString('\n')
	if err != nil {
		return "", errors.WithStackTrace(err)
	}

	return strings.TrimSpace(text), nil
}

// Prompt the user for a yes/no response and return true if they entered yes.
func PromptUserForYesNo(prompt string) (bool, error) {
	resp, err := PromptUserForInput(fmt.Sprintf("%s (y/n) ", prompt))

	if err != nil {
		return false, errors.WithStackTrace(err)
	}

	switch strings.ToLower(resp) {
	case "y", "yes":
		return true, nil
	default:
		return false, nil
	}
}

// Clear the terminal screen in a cross-platform compatible manner
func ClearTerminal() {
	screen.Clear()
}
-- util/shell.go --
package util

import (
	"os"
	"os/exec"
	"strings"

	"github.com/gruntwork-io/boilerplate/errors"
)

// Run the given shell command with the given environment variables and arguments in the given working directory
func RunShellCommandAndGetOutput(workingDir string, envVars []string, command string, args ...string) (string, error) {
	Logger.Printf("Running command: %s %s", command, strings.Join(args, " "))

	cmd := exec.Command(command, args...)

	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Dir = workingDir
	cmd.Env = append(os.Environ(), envVars...)

	out, err := cmd.Output()
	if err != nil {
		return "", errors.WithStackTrace(err)
	}
	return string(out), nil
}

// Run the given shell command with the given environment variables and arguments in the given working directory
func RunShellCommand(workingDir string, envVars []string, command string, args ...string) error {
	Logger.Printf("Running command: %s %s", command, strings.Join(args, " "))

	cmd := exec.Command(command, args...)

	cmd.Stdin = os.Stdin
	cmd.Stderr = os.Stderr
	cmd.Stdout = os.Stdout
	cmd.Dir = workingDir
	cmd.Env = append(os.Environ(), envVars...)

	return cmd.Run()
}
-- variables/dependencies.go --
package variables

import (
	"fmt"
	"strings"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/util"
)

// A single boilerplate template that this boilerplate.yml depends on being executed first
type Dependency struct {
	Name                 string
	TemplateUrl          string
	OutputFolder         string
	Skip                 string
	DontInheritVariables bool
	Variables            []Variable
	VarFiles             []string
	ForEach              []string
	ForEachReference     string
}

// Implement the go-yaml marshaler interface so that the config can be marshaled into yaml. We use a custom marshaler
// instead of defining the fields as tags so that we skip the attributes that are empty.
func (dependency Dependency) MarshalYAML() (interface{}, error) {
	depYml := map[string]interface{}{}
	if dependency.Name != "" {
		depYml["name"] = dependency.Name
	}
	if dependency.TemplateUrl != "" {
		depYml["template-url"] = dependency.TemplateUrl
	}
	if dependency.OutputFolder != "" {
		depYml["output-folder"] = dependency.OutputFolder
	}
	if dependency.Skip != "" {
		depYml["skip"] = dependency.Skip
	}
	if len(dependency.Variables) > 0 {
		// Due to go type system, we can only pass through []interface{}, even though []Variable is technically
		// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
		// function.
		interfaceList := []interface{}{}
		for _, variable := range dependency.Variables {
			interfaceList = append(interfaceList, variable)
		}
		varsYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		depYml["variables"] = varsYml
	}
	if len(dependency.VarFiles) > 0 {
		depYml["var_files"] = dependency.VarFiles
	}
	if len(dependency.ForEach) > 0 {
		depYml["for_each"] = dependency.ForEach
	}
	if len(dependency.ForEachReference) > 0 {
		depYml["for_each_reference"] = dependency.ForEachReference
	}
	return depYml, nil
}

// Given a unique variable name, return a tuple that contains the dependency name (if any) and the variable name.
// Variable and dependency names are split by a dot, so for "foo.bar", this will return ("foo", "bar"). For just "foo",
// it will return ("", "foo").
func SplitIntoDependencyNameAndVariableName(uniqueVariableName string) (string, string) {
	parts := strings.SplitAfterN(uniqueVariableName, ".", 2)
	if len(parts) == 2 {
		// The split method leaves the character you split on at the end of the string, so we have to trim it
		return strings.TrimSuffix(parts[0], "."), parts[1]
	} else {
		return "", parts[0]
	}
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// dependencies:
//
//   - name: <NAME>
//     template-url: <TEMPLATE_URL>
//     output-folder: <OUTPUT_FOLDER>
//
//   - name: <NAME>
//     template-url: <TEMPLATE_URL>
//     output-folder: <OUTPUT_FOLDER>
//
// This method takes the data above and unmarshals it into a list of Dependency objects
func UnmarshalDependenciesFromBoilerplateConfigYaml(fields map[string]interface{}) ([]Dependency, error) {
	unmarshalledDependencies := []Dependency{}
	dependencyNames := []string{}

	listOfFields, err := unmarshalListOfFields(fields, "dependencies")
	if err != nil {
		return unmarshalledDependencies, err
	}

	for _, fields := range listOfFields {
		dependency, err := UnmarshalDependencyFromBoilerplateConfigYaml(fields)
		if err != nil {
			return unmarshalledDependencies, err
		}

		if util.ListContains(dependency.Name, dependencyNames) {
			return unmarshalledDependencies, errors.WithStackTrace(DuplicateDependencyName(dependency.Name))
		}
		dependencyNames = append(dependencyNames, dependency.Name)

		unmarshalledDependencies = append(unmarshalledDependencies, *dependency)
	}

	return unmarshalledDependencies, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// name: <NAME>
// template-url: <TEMPLATE_URL>
// output-folder: <OUTPUT_FOLDER>
//
// This method takes the data above and unmarshals it into a Dependency object
func UnmarshalDependencyFromBoilerplateConfigYaml(fields map[string]interface{}) (*Dependency, error) {
	name, err := unmarshalStringField(fields, "name", true, "")
	if err != nil {
		return nil, err
	}

	templateUrl, err := unmarshalStringField(fields, "template-url", true, *name)
	if err != nil {
		return nil, err
	}

	outputFolder, err := unmarshalStringField(fields, "output-folder", true, *name)
	if err != nil {
		return nil, err
	}

	skipPtr, err := unmarshalStringField(fields, "skip", false, *name)
	if err != nil {
		return nil, err
	}
	var skip string
	if skipPtr != nil {
		skip = *skipPtr
	}

	dontInheritVariables, err := unmarshalBooleanField(fields, "dont-inherit-variables", false, *name)
	if err != nil {
		return nil, err
	}

	variables, err := UnmarshalVariablesFromBoilerplateConfigYaml(fields)
	if err != nil {
		return nil, err
	}

	varFiles, err := UnmarshalListOfStrings(fields, "var_files")
	if err != nil {
		return nil, err
	}

	forEach, err := UnmarshalListOfStrings(fields, "for_each")
	if err != nil {
		return nil, err
	}

	forEachReferencePtr, err := UnmarshalString(fields, "for_each_reference", false)
	if err != nil {
		return nil, err
	}
	forEachReference := ""
	if forEachReferencePtr != nil {
		forEachReference = *forEachReferencePtr
	}

	return &Dependency{
		Name:                 *name,
		TemplateUrl:          *templateUrl,
		OutputFolder:         *outputFolder,
		Skip:                 skip,
		DontInheritVariables: dontInheritVariables,
		Variables:            variables,
		VarFiles:             varFiles,
		ForEach:              forEach,
		ForEachReference:     forEachReference,
	}, nil
}

// Custom error types

type DuplicateDependencyName string

func (name DuplicateDependencyName) Error() string {
	return fmt.Sprintf("Found a duplicate dependency name: %s. All dependency names must be unique!", string(name))
}
-- variables/dependencies_test.go --
package variables

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestSplitIntoDependencyNameAndVariableName(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		variableName                 string
		expectedDependencyName       string
		expectedOriginalVariableName string
	}{
		{"", "", ""},
		{"foo", "", "foo"},
		{"foo-bar baz_blah", "", "foo-bar baz_blah"},
		{"foo.bar", "foo", "bar"},
		{"foo.bar.baz", "foo", "bar.baz"},
	}

	for _, testCase := range testCases {
		actualDependencyName, actualOriginalVariableName := SplitIntoDependencyNameAndVariableName(testCase.variableName)
		assert.Equal(t, testCase.expectedDependencyName, actualDependencyName, "Variable name: %s", testCase.variableName)
		assert.Equal(t, testCase.expectedOriginalVariableName, actualOriginalVariableName, "Variable name: %s", testCase.variableName)
	}
}
-- variables/engines.go --
package variables

import (
	"fmt"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/util"
)

// A single engine entry, which specifies which template engine should be used to render the given files grabbed by the
// glob. Currently only the following template engines are supported:
//
// - Go template (default)
// - Jsonnet
//
type Engine struct {
	Path           string             `yaml:"path"`
	TemplateEngine TemplateEngineType `yaml:"template_engine"`
}

type TemplateEngineType string

const (
	GoTemplate            TemplateEngineType = "go-template"
	Jsonnet               TemplateEngineType = "jsonnet"
	DefaultTemplateEngine                    = GoTemplate
)

// availableTemplateEngines is a list of string representations of the TemplateEngineType enum. This is used for
// validating user input.
var availableTemplateEngines = []string{
	string(GoTemplate),
	string(Jsonnet),
}

// Given a list of key:value pairs read from a Boilerplate YAML config file of the format:
//
// engines:
//   - path: <PATH>
//     template_engine: <TEMPLATE_ENGINE>
//
// convert to a list of Engine structs.
func UnmarshalEnginesFromBoilerplateConfigYaml(fields map[string]interface{}) ([]Engine, error) {
	rawEngines, err := unmarshalListOfFields(fields, "engines")
	if err != nil || rawEngines == nil {
		return nil, err
	}

	engines := []Engine{}

	for _, rawEngine := range rawEngines {
		engine, err := unmarshalEngineFromBoilerplateConfigYaml(rawEngine)
		if err != nil {
			return nil, err
		}
		// We only return nil pointer when there is an error, so we can assume engine is non-nil at this point.
		engines = append(engines, *engine)
	}

	return engines, nil
}

// Given key:value pairs read from a Boilerplate YAML config file of the format:
//
// path: <PATH>
// template_engine: <TEMPLATE_ENGINE>
//
// This method unmarshals the YAML data into an Engine struct
func unmarshalEngineFromBoilerplateConfigYaml(fields map[string]interface{}) (*Engine, error) {
	pathPtr, err := unmarshalStringField(fields, "path", true, "")
	if err != nil {
		return nil, err
	}

	// unmarshalStringField only returns nil pointer if there is an error, so we can assume it is not nil here.
	path := *pathPtr

	templateEnginePtr, err := unmarshalStringField(fields, "template_engine", true, path)
	if err != nil {
		return nil, err
	}

	// unmarshalStringField only returns nil pointer if there is an error, so we can assume it is not nil here.
	maybeTemplateEngine := *templateEnginePtr

	// Validate the template engine conforms to enum.
	if util.ListContains(maybeTemplateEngine, availableTemplateEngines) == false {
		return nil, errors.WithStackTrace(InvalidTemplateEngineErr(maybeTemplateEngine))
	}

	return &Engine{Path: path, TemplateEngine: TemplateEngineType(maybeTemplateEngine)}, nil
}

// Custom errors
type InvalidTemplateEngineErr string

func (err InvalidTemplateEngineErr) Error() string {
	return fmt.Sprintf("%s is not a valid template engine. Must be one of %v", string(err), availableTemplateEngines)
}
-- variables/engines_test.go --
package variables

import (
	"fmt"
	"testing"

	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/stretchr/testify/assert"
)

func TestEnginesRequiresSupportedTemplateEngine(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		name        string
		typeStr     string
		expectError bool
	}{
		{
			name:        "gotemplate",
			typeStr:     string(GoTemplate),
			expectError: false,
		},
		{
			name:        "jsonnet",
			typeStr:     string(Jsonnet),
			expectError: false,
		},
		{
			name:        "unsupported",
			typeStr:     "dhall",
			expectError: true,
		},
	}

	for _, tc := range testCases {
		// Capture range variable so it does not change across for loop iterations.
		tc := tc

		t.Run(tc.name, func(t *testing.T) {
			t.Parallel()

			mockFields := map[string]interface{}{
				"engines": []interface{}{
					map[interface{}]interface{}{
						"path":            fmt.Sprintf("foo.%s", tc.name),
						"template_engine": tc.typeStr,
					},
				},
			}
			_, err := UnmarshalEnginesFromBoilerplateConfigYaml(mockFields)
			if tc.expectError {
				assert.Error(t, err)
				underlyingErr := errors.Unwrap(err)
				_, hasType := underlyingErr.(InvalidTemplateEngineErr)
				assert.True(t, hasType)
			} else {
				assert.NoError(t, err)
			}
		})
	}
}
-- variables/hooks.go --
package variables

import (
	"github.com/gruntwork-io/boilerplate/util"
)

// A single hook, which is a command that is executed by boilerplate
type Hook struct {
	Command    string
	Args       []string
	Env        map[string]string
	Skip       string
	WorkingDir string
}

// All the scripts to execute as boilerplate hooks
type Hooks struct {
	BeforeHooks []Hook
	AfterHooks  []Hook
}

// Implement the go-yaml marshaler interface so that the config can be marshaled into yaml. We use a custom marshaler
// instead of defining the fields as tags so that we skip the attributes that are empty.
func (hook Hook) MarshalYAML() (interface{}, error) {
	hookYml := map[string]interface{}{}
	if hook.Command != "" {
		hookYml["command"] = hook.Command
	}
	if hook.Skip != "" {
		hookYml["skip"] = hook.Skip
	}
	if len(hook.Args) > 0 {
		hookYml["args"] = hook.Args
	}
	if len(hook.Env) > 0 {
		hookYml["env"] = hook.Env
	}
	if len(hook.WorkingDir) > 0 {
		hookYml["dir"] = hook.WorkingDir
	}
	return hookYml, nil
}
func (hooks Hooks) MarshalYAML() (interface{}, error) {
	hooksYml := map[string]interface{}{}
	// Due to go type system, we can only pass through []interface{}, even though []Hook is technically
	// polymorphic to that type. So we reconstruct the list using the right type before passing it in to the marshal
	// function.
	if len(hooks.BeforeHooks) > 0 {
		interfaceList := []interface{}{}
		for _, hook := range hooks.BeforeHooks {
			interfaceList = append(interfaceList, hook)
		}
		beforeYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		hooksYml["before"] = beforeYml
	}
	if len(hooks.AfterHooks) > 0 {
		interfaceList := []interface{}{}
		for _, hook := range hooks.AfterHooks {
			interfaceList = append(interfaceList, hook)
		}
		afterYml, err := util.MarshalListOfObjectsToYAML(interfaceList)
		if err != nil {
			return nil, err
		}
		hooksYml["after"] = afterYml
	}
	return hooksYml, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// hooks:
//
//	before:
//	  - command: <CMD>
//	    args:
//	      - <ARG>
//	    env:
//	      <KEY>: <VALUE>
//	    skip: <CONDITION>
//
//	after:
//	  - command: <CMD>
//	    args:
//	      - <ARG>
//	    env:
//	      <KEY>: <VALUE>
//	    skip: <CONDITION>
//
// This method takes the data above and unmarshals it into a Hooks struct
func UnmarshalHooksFromBoilerplateConfigYaml(fields map[string]interface{}) (Hooks, error) {
	hookFields, err := unmarshalMapOfFields(fields, "hooks")
	if err != nil {
		return Hooks{}, err
	}

	beforeHooks, err := unmarshalHooksFromBoilerplateConfigYaml(hookFields, "before")
	if err != nil {
		return Hooks{}, err
	}

	afterHooks, err := unmarshalHooksFromBoilerplateConfigYaml(hookFields, "after")
	if err != nil {
		return Hooks{}, err
	}

	return Hooks{BeforeHooks: beforeHooks, AfterHooks: afterHooks}, nil
}

// Given a list of key:value pairs read from a Boilerplate YAML config file of the format:
//
// hookName:
//
//   - command: <CMD>
//     args:
//
//   - <ARG>
//     env:
//     <KEY>: <VALUE>
//
//   - command: <CMD>
//     args:
//
//   - <ARG>
//     env:
//     <KEY>: <VALUE>
//
// This method takes looks up the given hookName in the map and unmarshals the data inside of it it into a list of
// Hook structs
func unmarshalHooksFromBoilerplateConfigYaml(fields map[string]interface{}, hookName string) ([]Hook, error) {
	hookFields, err := unmarshalListOfFields(fields, hookName)
	if err != nil || hookFields == nil {
		return nil, err
	}

	hooks := []Hook{}

	for _, hookField := range hookFields {
		hook, err := unmarshalHookFromBoilerplateConfigYaml(hookField, hookName)
		if err != nil {
			return nil, err
		}
		hooks = append(hooks, *hook)
	}

	return hooks, nil
}

// Given key:value pairs read from a Boilerplate YAML config file of the format:
//
// command: <CMD>
// args:
//   - <ARG>
//
// env:
//
//	<KEY>: <VALUE>
//
// This method unmarshals the YAML data into a Hook struct
func unmarshalHookFromBoilerplateConfigYaml(fields map[string]interface{}, hookName string) (*Hook, error) {
	command, err := unmarshalStringField(fields, "command", true, hookName)
	if err != nil {
		return nil, err
	}

	args, err := UnmarshalListOfStrings(fields, "args")
	if err != nil {
		return nil, err
	}

	env, err := unmarshalMapOfStrings(fields, "env")
	if err != nil {
		return nil, err
	}

	var workingDir string
	dir, err := unmarshalStringField(fields, "dir", false, hookName)
	if err != nil {
		return nil, err
	}
	if dir != nil {
		workingDir = *dir
	}

	skipPtr, err := unmarshalStringField(fields, "skip", false, hookName)
	if err != nil {
		return nil, err
	}
	var skip string
	if skipPtr != nil {
		skip = *skipPtr
	}

	return &Hook{Command: *command, Args: args, Env: env, Skip: skip, WorkingDir: workingDir}, nil
}
-- variables/skip_files.go --
package variables

import "github.com/gruntwork-io/boilerplate/errors"

// A single skip_file entry, which is a file that (conditionally) should be excluded from the rendered output.
type SkipFile struct {
	Path    string
	NotPath string
	If      string
}

// Implement the go-yaml marshaler interface so that the config can be marshaled into yaml. We use a custom marshaler
// instead of defining the fields as tags so that we skip the attributes that are empty.
func (skipFile SkipFile) MarshalYAML() (interface{}, error) {
	skipFileYml := map[string]interface{}{}
	if skipFile.Path != "" {
		skipFileYml["path"] = skipFile.Path
	}
	if skipFile.NotPath != "" {
		skipFileYml["not_path"] = skipFile.Path
	}
	if skipFile.If != "" {
		skipFileYml["if"] = skipFile.If
	}
	return skipFileYml, nil
}

// Given a list of key:value pairs read from a Boilerplate YAML config file of the format:
//
// skip_files:
//   - path: <PATH>
//     if: <SKIPIF>
//   - path: <PATH>
//   - not_path: <PATH>
//
// convert to a list of SkipFile structs.
func UnmarshalSkipFilesFromBoilerplateConfigYaml(fields map[string]interface{}) ([]SkipFile, error) {
	rawSkipFiles, err := unmarshalListOfFields(fields, "skip_files")
	if err != nil || rawSkipFiles == nil {
		return nil, err
	}

	skipFiles := []SkipFile{}

	for _, rawSkipFile := range rawSkipFiles {
		skipFile, err := unmarshalSkipFileFromBoilerplateConfigYaml(rawSkipFile)
		if err != nil {
			return nil, err
		}
		// We only return nil pointer when there is an error, so we can assume skipFile is non-nil at this point.
		skipFiles = append(skipFiles, *skipFile)
	}

	return skipFiles, nil
}

// Given key:value pairs read from a Boilerplate YAML config file of the format:
//
// path: <PATH>
// not_path: <PATH>
// if: <SKIPIF>
//
// This method unmarshals the YAML data into a SkipFile struct
func unmarshalSkipFileFromBoilerplateConfigYaml(fields map[string]interface{}) (*SkipFile, error) {
	pathPtr, err := unmarshalStringField(fields, "path", false, "")
	if err != nil {
		return nil, err
	}
	path := ""
	if pathPtr != nil {
		path = *pathPtr
	}

	notPathPtr, err := unmarshalStringField(fields, "not_path", false, "")
	if err != nil {
		return nil, err
	}
	notPath := ""
	if notPathPtr != nil {
		notPath = *notPathPtr
	}

	// One of not_path or path must be set, so we check that here.
	if (notPath == "" && path == "") || (notPath != "" && path != "") {
		return nil, errors.WithStackTrace(MutexRequiredFieldErr{fields: []string{"path", "not_path"}})
	}

	skipIfPtr, err := unmarshalStringField(fields, "if", false, path)
	if err != nil {
		return nil, err
	}
	skipIf := ""
	if skipIfPtr != nil {
		skipIf = *skipIfPtr
	}

	return &SkipFile{Path: path, NotPath: notPath, If: skipIf}, nil
}
-- variables/types.go --
package variables

import (
	"fmt"

	"github.com/gruntwork-io/boilerplate/errors"
)

// An enum that represents the types we support for boilerplate variables
type BoilerplateType string

var (
	String = BoilerplateType("string")
	Int    = BoilerplateType("int")
	Float  = BoilerplateType("float")
	Bool   = BoilerplateType("bool")
	List   = BoilerplateType("list")
	Map    = BoilerplateType("map")
	Enum   = BoilerplateType("enum")
)

var ALL_BOILERPLATE_TYPES = []BoilerplateType{String, Int, Float, Bool, List, Map, Enum}
var BOILERPLATE_TYPE_DEFAULT = String

// Convert the given string to a BoilerplateType enum, or return an error if this is not a valid value for the
// BoilerplateType enum
func ParseBoilerplateType(str string) (*BoilerplateType, error) {
	for _, boilerplateType := range ALL_BOILERPLATE_TYPES {
		if boilerplateType.String() == str {
			return &boilerplateType, nil
		}
	}
	return nil, errors.WithStackTrace(InvalidBoilerplateType(str))
}

// Return a string representation of this Type
func (boilerplateType BoilerplateType) String() string {
	return string(boilerplateType)
}

type InvalidEntries struct {
	Issues []ValidationIssue
}

type ValidationIssue struct {
	Value         interface{}
	ValidationMap map[string]bool
}

// Custom error types

type InvalidBoilerplateType string

func (err InvalidBoilerplateType) Error() string {
	return fmt.Sprintf("Invalid InvalidBoilerplateType '%s'. Value must be one of: %s", string(err), ALL_BOILERPLATE_TYPES)
}
-- variables/variables.go --
package variables

import (
	"encoding/json"
	"fmt"
	"reflect"
	"regexp"
	"strconv"
	"strings"

	"github.com/gruntwork-io/boilerplate/errors"
)

// An interface for a variable defined in a boilerplate.yml config file
type Variable interface {
	// The name of the variable
	Name() string

	// The full name of this variable, which includes its name and the dependency it is for (if any) in a
	// human-readable format
	FullName() string

	// The description of the variable, if any
	Description() string

	// The type of the variable
	Type() BoilerplateType

	// The user-defined sorting position of the variable
	Order() int

	// The default value for the variable, if any
	Default() interface{}

	// The name of another variable from which this variable should take its value
	Reference() string

	// The values this variable can take. Applies only if Type() is Enum.
	Options() []string

	// Return a copy of this variable but with the name set to the given name
	WithName(string) Variable

	// Return a copy of this variable but with the description set to the given description
	WithDescription(string) Variable

	// Return a copy of this variable but with the default set to the given value
	WithDefault(interface{}) Variable

	// Create a human-readable, string representation of the variable
	String() string

	// Show an example value that would be valid for this variable
	ExampleValue() string

	// A custom marshaling function to translate back to YAML, as expected by go-yaml.
	MarshalYAML() (interface{}, error)

	// Validations that should be run on the variable
	Validations() []CustomValidationRule
}

// A private implementation of the Variable interface that forces all users to use our public constructors
type defaultVariable struct {
	name         string
	description  string
	defaultValue interface{}
	reference    string
	variableType BoilerplateType
	order        int
	options      []string
	validations  []CustomValidationRule
}

// Create a new variable that holds a string
func NewStringVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: String,
	}
}

// Create a new variable that holds an int
func NewIntVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: Int,
	}
}

// Create a new variable that holds a float
func NewFloatVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: Float,
	}
}

// Create a new variable that holds a bool
func NewBoolVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: Bool,
	}
}

// Create a new variable that holds a list of strings
func NewListVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: List,
	}
}

// Create a new variable that holds a map of string to string
func NewMapVariable(name string) Variable {
	return defaultVariable{
		name:         name,
		variableType: Map,
	}
}

// Create a new variable that holds an enum with the given possible values
func NewEnumVariable(name string, options []string) Variable {
	return defaultVariable{
		name:         name,
		variableType: Enum,
		options:      options,
	}
}

func (variable defaultVariable) Name() string {
	return variable.name
}

func (variable defaultVariable) FullName() string {
	dependencyName, variableName := SplitIntoDependencyNameAndVariableName(variable.Name())
	if dependencyName == "" {
		return variableName
	} else {
		return fmt.Sprintf("%s (for dependency %s)", variableName, dependencyName)
	}
}

func (variable defaultVariable) Description() string {
	return variable.description
}

func (variable defaultVariable) Type() BoilerplateType {
	return variable.variableType
}

func (variable defaultVariable) Order() int {
	return variable.order
}

func (variable defaultVariable) Default() interface{} {
	return variable.defaultValue
}

func (variable defaultVariable) Reference() string {
	return variable.reference
}

func (variable defaultVariable) Options() []string {
	return variable.options
}

func (variable defaultVariable) Validations() []CustomValidationRule {
	return variable.validations
}

func (variable defaultVariable) WithName(name string) Variable {
	variable.name = name
	return variable
}

func (variable defaultVariable) WithDescription(description string) Variable {
	variable.description = description
	return variable
}

func (variable defaultVariable) WithDefault(value interface{}) Variable {
	variable.defaultValue = value
	return variable
}

func (variable defaultVariable) String() string {
	return fmt.Sprintf("Variable {Name: '%s', Description: '%s', Type: '%v', Default: '%v', Options: '%v', Reference: '%v'}", variable.Name(), variable.Description(), variable.Type(), variable.Default(), variable.Options(), variable.Reference())
}

func (variable defaultVariable) ExampleValue() string {
	switch variable.Type() {
	case String:
		return "foo"
	case Int:
		return "42"
	case Float:
		return "3.1415926"
	case Bool:
		return "true or false"
	case List:
		return "[foo, bar, baz]"
	case Map:
		return "{foo: bar, baz: blah}"
	case Enum:
		return fmt.Sprintf("must be one of: %s", variable.Options())
	default:
		return ""
	}
}

// Define a custom marshaler for YAML so that variables (and thus any struct using it) can be marshaled into YAML.
func (variable defaultVariable) MarshalYAML() (interface{}, error) {
	varYml := map[string]interface{}{}
	// We avoid a straight assignment to ensure that only fields that are actually set are rendered out.
	if variable.Name() != "" {
		varYml["name"] = variable.Name()
	}
	if variable.Description() != "" {
		varYml["description"] = variable.Description()
	}
	if variable.Type() != "" {
		varYml["type"] = variable.Type()
	}
	if variable.Default() != nil {
		varYml["default"] = variable.Default()
	}
	if variable.Reference() != "" {
		varYml["reference"] = variable.Reference()
	}
	if len(variable.Options()) > 0 {
		varYml["options"] = variable.Options()
	}
	if len(variable.Validations()) > 0 {
		varYml["validations"] = variable.Validations()
	}
	return varYml, nil
}

// Check that the given value matches the type we're expecting in the given variable and return an error if it doesn't
func ConvertType(value interface{}, variable Variable) (interface{}, error) {
	if value == nil {
		return nil, nil
	}

	asString, isString := value.(string)

	switch variable.Type() {
	case String:
		if isString {
			return asString, nil
		}
	case Int:
		if asInt, isInt := value.(int); isInt {
			return asInt, nil
		}
		if isString {
			return strconv.Atoi(asString)
		}
	case Float:
		if asFloat, isFloat := value.(float64); isFloat {
			return asFloat, nil
		}
		if isString {
			return strconv.ParseFloat(asString, 64)
		}
	case Bool:
		if asBool, isBool := value.(bool); isBool {
			return asBool, nil
		}
		if isString {
			return strconv.ParseBool(asString)
		}
	case List:
		if reflect.TypeOf(value).Kind() == reflect.Slice {
			return value, nil
		}
		if isString {
			return parseStringAsList(asString)
		}
	case Map:
		if reflect.TypeOf(value).Kind() == reflect.Map {
			value, err := ConvertYAMLToStringMap(value)
			if err != nil {
				return nil, err
			}
			return value, nil
		}
		if isString {
			return parseStringAsMap(asString)
		}
	case Enum:
		if isString {
			for _, option := range variable.Options() {
				if asString == option {
					return asString, nil
				}
			}
		}
	}

	return nil, InvalidVariableValue{Variable: variable, Value: value}
}

var GO_LIST_SYNTAX_REGEX = regexp.MustCompile(`\[(.*)]`)
var GO_MAP_SYNTAX_REGEX = regexp.MustCompile(`map\[(.*)]`)

// This method converts a string to a list. The string can either be a valid JSON list or the string output of a Go
// list.
func parseStringAsList(str string) ([]string, error) {
	jsonOut, jsonErr := parseStringAsJsonList(str)
	if jsonErr == nil {
		return jsonOut, nil
	}

	goOut, goErr := parseStringAsGoList(str)
	if goErr == nil {
		return goOut, nil
	}

	return nil, errors.WithStackTrace(FormatNotJsonOrGo{
		ExpectedJsonFormat: `["value1", "value2", "value3"]`,
		ExpectedGoFormat:   `[value1 value2 value3]`,
		ActualFormat:       str,
		JsonErr:            jsonErr,
		GoErr:              goErr,
	})
}

// If you render a list in Go, it'll have the format [<value> <value> <value>]. This method parses this format back
// into a Go list. This allows us to use Golang template syntax in variable values and still have the rendered value
// converted back to the proper type rather than a string.
//
// Note that this is a bit of a hack and should generally not be used, as it's not possible to unambiguously parse
// lists in Go that had spaces in the values.
func parseStringAsGoList(str string) ([]string, error) {
	matches := GO_LIST_SYNTAX_REGEX.FindStringSubmatch(str)

	if len(matches) != 2 {
		return nil, errors.WithStackTrace(ParseError{ExpectedType: "list", ExpectedFormat: "[<value> <value> <value>]", ActualFormat: str})
	}

	items := strings.TrimSpace(matches[1])

	if len(items) == 0 {
		return []string{}, nil
	}

	return strings.Split(items, " "), nil
}

// Parse a string as a JSON list
func parseStringAsJsonList(str string) ([]string, error) {
	var out []string

	if err := json.Unmarshal([]byte(str), &out); err != nil {
		return nil, errors.WithStackTrace(err)
	}

	return out, nil
}

// This method converts a string to a map. The string can either be a valid JSON map or the string output of a Go map.
func parseStringAsMap(str string) (map[string]string, error) {
	jsonOut, jsonErr := parseStringAsJsonMap(str)
	if jsonErr == nil {
		return jsonOut, nil
	}

	goOut, goErr := parseStringAsGoMap(str)
	if goErr == nil {
		return goOut, nil
	}

	return nil, errors.WithStackTrace(FormatNotJsonOrGo{
		ExpectedJsonFormat: `{"key1": "value1", "key2": "value2", "key3": "value3"}`,
		ExpectedGoFormat:   `map[key1:value1 key2:value2 key3:value3]`,
		ActualFormat:       str,
		JsonErr:            jsonErr,
		GoErr:              goErr,
	})
}

// If you render a map in Go, it'll have the format map[<key>:<value> <key>:<value> <key>:<value>]. This method parses
// this format back into a Go map. This allows us to use Golang template syntax in variable values and still have the
// rendered value converted back to the proper type rather than a string.
//
// Note that this is a bit of a hack and should generally not be used, as it's not possible to unambiguously parse
// maps in Go that had spaces in the keys or values.
func parseStringAsGoMap(str string) (map[string]string, error) {
	matches := GO_MAP_SYNTAX_REGEX.FindStringSubmatch(str)

	if len(matches) != 2 {
		return nil, errors.WithStackTrace(ParseError{ExpectedType: "map", ExpectedFormat: "[<key>:<value> <key>:<value> <key>:<value>]", ActualFormat: str})
	}

	items := strings.TrimSpace(matches[1])

	if len(items) == 0 {
		return map[string]string{}, nil
	}

	keysAndValues := strings.Split(items, " ")
	result := map[string]string{}

	for _, keyAndValue := range keysAndValues {
		parts := strings.Split(keyAndValue, ":")
		if len(parts) < 2 {
			return nil, errors.WithStackTrace(ParseError{ExpectedType: "map", ExpectedFormat: "<key>:<value> for each item in the map", ActualFormat: str})
		}

		key := strings.Join(parts[:(len(parts)-1)], ":")
		value := parts[len(parts)-1]

		result[key] = value
	}

	return result, nil
}

// Parse a string as a JSON map
func parseStringAsJsonMap(str string) (map[string]string, error) {
	var out map[string]string

	if err := json.Unmarshal([]byte(str), &out); err != nil {
		return nil, errors.WithStackTrace(err)
	}

	return out, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// variables:
//
//   - name: <NAME>
//     description: <DESCRIPTION>
//     type: <TYPE>
//
//   - name: <NAME>
//     description: <DESCRIPTION>
//     default: <DEFAULT>
//
// This method takes the data above and unmarshals it into a list of Variable objects
func UnmarshalVariablesFromBoilerplateConfigYaml(fields map[string]interface{}) ([]Variable, error) {
	unmarshalledVariables := []Variable{}

	listOfFields, err := unmarshalListOfFields(fields, "variables")
	if err != nil {
		return unmarshalledVariables, err
	}

	for _, fields := range listOfFields {
		variable, err := UnmarshalVariableFromBoilerplateConfigYaml(fields)
		if err != nil {
			return unmarshalledVariables, err
		}
		unmarshalledVariables = append(unmarshalledVariables, variable)
	}

	return unmarshalledVariables, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// name: <NAME>
// description: <DESCRIPTION>
// type: <TYPE>
// default: <DEFAULT>
//
// This method takes the data above and unmarshals it into a Variable object
func UnmarshalVariableFromBoilerplateConfigYaml(fields map[string]interface{}) (Variable, error) {
	variable := defaultVariable{}

	name, err := unmarshalStringField(fields, "name", true, "")
	if err != nil {
		return nil, err
	}
	variable.name = *name

	variableType, err := unmarshalTypeField(fields, *name)
	if err != nil {
		return nil, err
	}
	variable.variableType = variableType

	order, err := unmarshalIntField(fields, "order", false, *name)
	if err != nil {
		return nil, err
	}
	if order != nil {
		variable.order = *order
	}

	description, err := unmarshalStringField(fields, "description", false, *name)
	if err != nil {
		return nil, err
	}
	if description != nil {
		variable.description = *description
	}

	reference, err := unmarshalStringField(fields, "reference", false, *name)
	if err != nil {
		return nil, err
	}
	if reference != nil {
		variable.reference = *reference
	}

	options, err := unmarshalOptionsField(fields, *name, variableType)
	if err != nil {
		return nil, err
	}
	variable.options = options

	validationRules, err := unmarshalValidationsField(fields)
	if err != nil {
		return nil, err
	}
	variable.validations = validationRules

	variable.defaultValue = fields["default"]

	return variable, nil
}

// Custom error types

type ParseError struct {
	ExpectedType   string
	ExpectedFormat string
	ActualFormat   string
}

func (err ParseError) Error() string {
	return fmt.Sprintf("Expected type '%s' with format '%s', but got format '%s'.", err.ExpectedType, err.ExpectedFormat, err.ActualFormat)
}

type FormatNotJsonOrGo struct {
	ExpectedJsonFormat string
	ExpectedGoFormat   string
	ActualFormat       string
	JsonErr            error
	GoErr              error
}

func (err FormatNotJsonOrGo) Error() string {
	return fmt.Sprintf("Expected a string in JSON format (e.g., %s) or Go format (e.g., %s), but got: %s. JSON parsing error: %v. Go parsing error: %v.", err.ExpectedJsonFormat, err.ExpectedGoFormat, err.ActualFormat, err.JsonErr, err.GoErr)
}
-- variables/variables_test.go --
package variables

import (
	"testing"

	"github.com/stretchr/testify/assert"
)

func TestParseStringAsList(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		testName     string
		str          string
		expectedList []string
	}{
		{"empty-list", "[]", []string{}},
		{"one-item", "[a]", []string{"a"}},
		{"three-items", "[a b c]", []string{"a", "b", "c"}},
		{"leading-trailing-whitespace", "[ a b c ]", []string{"a", "b", "c"}},
		{"json-list-one-item", `["a"]`, []string{"a"}},
		{"json-list-three-items", `["a", "b", "c"]`, []string{"a", "b", "c"}},
	}

	for _, testCase := range testCases {
		t.Run(testCase.testName, func(t *testing.T) {
			actualList, err := parseStringAsList(testCase.str)
			assert.Nil(t, err, "Got unexpected error for string '%s': %v", testCase.str, err)
			assert.Equal(t, testCase.expectedList, actualList, "For string '%s'", testCase.str)
		})
	}

}

func TestParseStringAsMap(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		testName    string
		str         string
		expectedMap map[string]string
	}{
		{"empty-map", "map[]", map[string]string{}},
		{"one-item", "map[a:b]", map[string]string{"a": "b"}},
		{"three-items", "map[a:b c:d e:f]", map[string]string{"a": "b", "c": "d", "e": "f"}},
		{"multiple-colons", "map[a:b:c:d:e]", map[string]string{"a:b:c:d": "e"}},
		{"leading-trailing-whitespace", "map[ a:b c:d e:f ]", map[string]string{"a": "b", "c": "d", "e": "f"}},
		{"json-map-empty", `{}`, map[string]string{}},
		{"json-map-one-item", `{"a": "b"}`, map[string]string{"a": "b"}},
		{"json-map-three-items", `{"a": "b", "c": "d", "e": "f"}`, map[string]string{"a": "b", "c": "d", "e": "f"}},
	}

	for _, testCase := range testCases {
		t.Run(testCase.testName, func(t *testing.T) {
			actualMap, err := parseStringAsMap(testCase.str)
			assert.Nil(t, err, "Got unexpected error for string '%s': %v", testCase.str, err)
			assert.Equal(t, testCase.expectedMap, actualMap, "For string '%s'", testCase.str)
		})
	}

}
-- variables/yaml_helpers.go --
package variables

import (
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"

	validation "github.com/go-ozzo/ozzo-validation"
	"github.com/go-ozzo/ozzo-validation/is"
	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/gruntwork-io/boilerplate/util"
	"gopkg.in/yaml.v2"
)

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName:
//
//	key1: value1
//	key2: value2
//	key3: value3
//
// This method looks up the given fieldName in the map and unmarshals the data inside of it it into a map of the
// key:value pairs.
func unmarshalMapOfFields(fields map[string]any, fieldName string) (map[string]interface{}, error) {
	fieldAsYaml, containsField := fields[fieldName]
	if !containsField || fieldAsYaml == nil {
		return nil, nil
	}

	asYamlMap, isYamlMap := fieldAsYaml.(map[any]interface{})
	if !isYamlMap {
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "map[string]any", ActualType: reflect.TypeOf(fieldAsYaml)})
	}

	stringMap := map[string]any{}
	for key, value := range asYamlMap {
		if keyAsString, isString := key.(string); isString {
			stringMap[keyAsString] = value
		} else {
			return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "string", ActualType: reflect.TypeOf(key)})
		}
	}

	return stringMap, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName:
//
//	key1: value1
//	key2: value2
//	key3: value3
//
// This method looks up the given fieldName in the map and unmarshals the data inside of it it into a map of the
// key:value pairs, where both the keys and values are strings.
func unmarshalMapOfStrings(fields map[string]any, fieldName string) (map[string]string, error) {
	rawMap, err := unmarshalMapOfFields(fields, fieldName)
	if err != nil {
		return nil, err
	}
	if len(rawMap) == 0 {
		return nil, nil
	}

	stringMap := map[string]string{}

	for key, value := range rawMap {
		stringMap[key] = fmt.Sprintf("%v", value)
	}

	return stringMap, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName:
//   - value1
//   - value2
//   - value3
//
// This method takes looks up the given fieldName in the map and unmarshals the data inside of it it into a list of
// strings with the given values.
func UnmarshalListOfStrings(fields map[string]any, fieldName string) ([]string, error) {
	fieldAsYaml, containsField := fields[fieldName]
	if !containsField || fieldAsYaml == nil {
		return nil, nil
	}

	switch asList := fieldAsYaml.(type) {
	case []any:
		listOfStrings := []string{}

		for _, asYaml := range asList {
			if valueAsString, isString := asYaml.(string); isString {
				listOfStrings = append(listOfStrings, valueAsString)
			} else {
				return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "string", ActualType: reflect.TypeOf(asList)})
			}
		}

		return listOfStrings, nil
	case []string:
		return asList, nil
	default:
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "[]any or []string", ActualType: reflect.TypeOf(fieldAsYaml)})
	}
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName:
//
//   - key1: value1
//     key2: value2
//     key3: value3
//
//   - key1: value1
//     key2: value2
//     key3: value3
//
// This method takes looks up the given fieldName in the map and unmarshals the data inside of it it into a list of
// maps, where each map contains the set of key:value pairs
func unmarshalListOfFields(fields map[string]any, fieldName string) ([]map[string]interface{}, error) {
	fieldAsYaml, containsField := fields[fieldName]
	if !containsField || fieldAsYaml == nil {
		return nil, nil
	}

	asYamlList, isYamlList := fieldAsYaml.([]any)
	if !isYamlList {
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "[]any", ActualType: reflect.TypeOf(fieldAsYaml)})
	}

	listOfFields := []map[string]any{}

	for _, asYaml := range asYamlList {
		asYamlMap, isYamlMap := asYaml.(map[any]interface{})
		if !isYamlMap {
			return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "map[string]any", ActualType: reflect.TypeOf(asYaml)})
		}

		listOfFields = append(listOfFields, util.ToStringToGenericMap(asYamlMap))
	}

	return listOfFields, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// options:
//   - foo
//   - bar
//   - baz
//
// This method takes looks up the options object in the map and unmarshals the data inside of it it into a list of
// strings. This is meant to be used to parse the options field of an Enum variable. If the given variableType is not
// an Enum and options have been specified, or this variable is an Enum and options have not been specified, this
// method will return an error.
func unmarshalOptionsField(fields map[string]any, context string, variableType BoilerplateType) ([]string, error) {
	options, hasOptions := fields["options"]

	if !hasOptions {
		if variableType == Enum {
			return nil, errors.WithStackTrace(OptionsMissing(context))
		} else {
			return nil, nil
		}
	}

	if variableType != Enum {
		return nil, errors.WithStackTrace(OptionsCanOnlyBeUsedWithEnum{Context: context, Type: variableType})
	}

	optionsAsList, isList := options.([]any)
	if !isList {
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: "options", ExpectedType: "List", ActualType: reflect.TypeOf(options), Context: context})
	}

	return util.ToStringList(optionsAsList), nil
}

type CustomValidationRule struct {
	Validator validation.Rule
	Message   string
}

type CustomValidationRuleCollection []CustomValidationRule

func (c CustomValidationRuleCollection) GetValidators() []validation.Rule {
	var validatorsToReturn []validation.Rule
	for _, rule := range c {
		validatorsToReturn = append(validatorsToReturn, rule.Validator)
	}
	return validatorsToReturn
}

func (c CustomValidationRule) DescriptionText() string {
	return c.Message
}

// parseRuleString converts the string representation of the validations field, as parsed from YAML,
// into a slice of strings that ConvertValidationStringtoRules can easily iterate over
func parseRuleString(ruleString string) []string {
	ruleString = strings.ReplaceAll(ruleString, "]", "")
	ruleString = strings.ReplaceAll(ruleString, "[", "")
	ruleString = strings.ToLower(ruleString)
	return strings.Split(ruleString, " ")
}

// ConvertValidationStringtoRules takes the string representation of the variable's validations and parses it
// into CustomValidationRules that should be run on the variable's value when submitted by a user
func ConvertValidationStringtoRules(ruleString string) ([]CustomValidationRule, error) {
	var validationRules []CustomValidationRule

	rules := parseRuleString(ruleString)

	for _, rule := range rules {

		var cvr CustomValidationRule

		switch {
		case strings.HasPrefix(rule, "length-"):
			valString := strings.TrimLeft(rule, "length-")
			valSlice := strings.Split(valString, "-")
			minStr := valSlice[0]
			maxStr := valSlice[1]
			min, minErr := strconv.Atoi(strings.TrimSpace(minStr))
			if minErr != nil {
				return validationRules, minErr
			}
			max, maxErr := strconv.Atoi(strings.TrimSpace(maxStr))
			if maxErr != nil {
				return validationRules, maxErr
			}
			cvr = CustomValidationRule{
				Validator: validation.Length(min, max),
				Message:   fmt.Sprintf("Must be between %d and %d characters long", min, max),
			}
		case rule == "required":
			cvr = CustomValidationRule{
				Validator: validation.Required,
				Message:   "Must not be empty",
			}
		case rule == "url":
			cvr = CustomValidationRule{
				Validator: is.URL,
				Message:   "Must be a valid URL",
			}
		case rule == "email":
			cvr = CustomValidationRule{
				Validator: is.Email,
				Message:   "Must be a valid email address",
			}
		case rule == "alpha":
			cvr = CustomValidationRule{
				Validator: is.Alpha,
				Message:   "Must contain English letters only",
			}
		case rule == "digit":
			cvr = CustomValidationRule{
				Validator: is.Digit,
				Message:   "Must contain digits only",
			}
		case rule == "alphanumeric":
			cvr = CustomValidationRule{
				Validator: is.Alphanumeric,
				Message:   "Can contain English letters and digits only",
			}
		case rule == "countrycode2":
			cvr = CustomValidationRule{
				Validator: is.CountryCode2,
				Message:   "Must be a valid ISO3166 Alpha 2 Country code",
			}
		case rule == "semver":
			cvr = CustomValidationRule{
				Validator: is.Semver,
				Message:   "Must be a valid semantic version",
			}
		}

		if cvr != (CustomValidationRule{}) {
			validationRules = append(validationRules, cvr)
		}
	}

	return validationRules, nil
}

// Given a list of validations read from a Boilerplate YAML config file of the format:
//
// This method looks up the validations specified in the map and applies them to the specified fields so that users prompted for input
// get real-time feedback on the validity of their entries
func unmarshalValidationsField(fields map[string]any) ([]CustomValidationRule, error) {
	validations := fields["validations"]

	validationsAsString := fmt.Sprintf("%v", validations)

	rules, err := ConvertValidationStringtoRules(validationsAsString)
	if err != nil {
		return []CustomValidationRule{}, err
	}

	return rules, nil
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// type: <TYPE>
//
// This method takes looks up the options key in the map and unmarshals the data inside of it it into a
// BoilerplateType. If no type is specified, this method returns the default type (String). If an unrecognized type is
// specified, this method returns an error.
func unmarshalTypeField(fields map[string]any, context string) (BoilerplateType, error) {
	variableTypeAsString, err := unmarshalStringField(fields, "type", false, context)
	if err != nil {
		return BOILERPLATE_TYPE_DEFAULT, err
	}

	if variableTypeAsString != nil {
		variableType, err := ParseBoilerplateType(*variableTypeAsString)
		if err != nil {
			return BOILERPLATE_TYPE_DEFAULT, err
		}
		return *variableType, nil
	}

	return BOILERPLATE_TYPE_DEFAULT, nil
}

func unmarshalIntField(fields map[string]any, fieldName string, requiredField bool, context string) (*int, error) {
	value, hasValue := fields[fieldName]
	if !hasValue {
		if requiredField {
			return nil, errors.WithStackTrace(RequiredFieldMissing(fieldName))
		} else {
			return nil, nil
		}
	}

	if valueAsInt, isInt := value.(int); isInt {
		return &valueAsInt, nil
	} else {
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "int", ActualType: reflect.TypeOf(value), Context: context})
	}
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName: <VALUE>
//
// This method takes looks up the given fieldName in the map and unmarshals the data inside of it into a string. If
// requiredField is true and fieldName was not in the map, this method will return an error.
func unmarshalStringField(fields map[string]any, fieldName string, requiredField bool, context string) (*string, error) {
	value, hasValue := fields[fieldName]
	if !hasValue {
		if requiredField {
			return nil, errors.WithStackTrace(RequiredFieldMissing(fieldName))
		} else {
			return nil, nil
		}
	}

	if valueAsString, isString := value.(string); isString {
		return &valueAsString, nil
	} else {
		return nil, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "string", ActualType: reflect.TypeOf(value), Context: context})
	}
}

// UnmarshalString is the public convenience interface for unmarshalStringField.
func UnmarshalString(fields map[string]any, fieldName string, isRequiredField bool) (*string, error) {
	return unmarshalStringField(fields, fieldName, isRequiredField, "")
}

// Given a map of key:value pairs read from a Boilerplate YAML config file of the format:
//
// fieldName: <VALUE>
//
// This method takes looks up the given fieldName in the map and unmarshals the data inside of it into a bool. If
// requiredField is true and fieldName was not in the map, this method will return an error.
func unmarshalBooleanField(fields map[string]any, fieldName string, requiredField bool, context string) (bool, error) {
	value, hasValue := fields[fieldName]
	if !hasValue {
		if requiredField {
			return false, errors.WithStackTrace(RequiredFieldMissing(fieldName))
		} else {
			return false, nil
		}
	}

	if valueAsBool, isBool := value.(bool); isBool {
		return valueAsBool, nil
	} else {
		return false, errors.WithStackTrace(InvalidTypeForField{FieldName: fieldName, ExpectedType: "bool", ActualType: reflect.TypeOf(value), Context: context})
	}
}

// parseVariablesFromEnvironmentVariables parses variables from environment variables
//
// These variables are expected to be in the format:
//
//	BOILERPLATE_var_name=value
func parseVariablesFromEnvironmentVariables() (map[string]any, error) {
	vars := map[string]any{}

	for _, envVar := range os.Environ() {
		if !strings.Contains(envVar, "BOILERPLATE_") {
			continue
		}

		key, value, found := strings.Cut(envVar, "=")
		if !found {
			return vars, errors.WithStackTrace(InvalidVarSyntax(envVar))
		}

		if strings.HasPrefix(key, "BOILERPLATE_") {
			key = strings.TrimPrefix(key, "BOILERPLATE_")
			parsedValue, err := ParseYamlString(value)
			if err != nil {
				return vars, err
			}

			vars[key] = parsedValue
		}
	}

	return vars, nil
}

// Parse a list of NAME=VALUE pairs passed in as command-line options into a map of variable names to variable values.
// Along the way, each value is parsed as YAML.
func parseVariablesFromKeyValuePairs(varsList []string) (map[string]any, error) {
	vars := map[string]any{}

	for _, variable := range varsList {
		key, value, found := strings.Cut(variable, "=")
		if !found {
			return vars, errors.WithStackTrace(InvalidVarSyntax(variable))
		}

		if key == "" {
			return vars, errors.WithStackTrace(VariableNameCannotBeEmpty(variable))
		}

		parsedValue, err := ParseYamlString(value)
		if err != nil {
			return vars, err
		}

		vars[key] = parsedValue
	}

	return vars, nil
}

// Parse a YAML string into a Go type
func ParseYamlString(str string) (any, error) {
	var parsedValue any

	err := yaml.Unmarshal([]byte(str), &parsedValue)
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}

	parsedValue, err = ConvertYAMLToStringMap(parsedValue)
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}

	return parsedValue, nil
}

// Parse a list of YAML files that define variables into a map from variable name to variable value. Along the way,
// each value is parsed as YAML.
func parseVariablesFromVarFiles(varFileList []string) (map[string]any, error) {
	vars := map[string]any{}

	for _, varFile := range varFileList {
		varsInFile, err := ParseVariablesFromVarFile(varFile)
		if err != nil {
			return vars, err
		}
		vars = util.MergeMaps(vars, varsInFile)
	}

	return vars, nil
}

// Parse the variables in the given YAML file into a map of variable name to variable value. Along the way, each value
// is parsed as YAML.
func ParseVariablesFromVarFile(varFilePath string) (map[string]any, error) {
	bytes, err := os.ReadFile(varFilePath)
	if err != nil {
		return map[string]any{}, errors.WithStackTrace(err)
	}
	return parseVariablesFromVarFileContents(bytes)
}

// Parse the variables in the given YAML contents into a map of variable name to variable value. Along the way, each
// value is parsed as YAML.
func parseVariablesFromVarFileContents(varFileContents []byte) (map[string]any, error) {
	vars := make(map[string]any)

	if err := yaml.Unmarshal(varFileContents, &vars); err != nil {
		return vars, err
	}

	converted, err := ConvertYAMLToStringMap(vars)
	if err != nil {
		return nil, errors.WithStackTrace(err)
	}

	vars, ok := converted.(map[string]any)
	if !ok {
		return nil, YAMLConversionErr{converted}
	}

	return vars, nil
}

// Parse variables passed in via command line options, either as a list of NAME=VALUE variable pairs in varsList, or a
// list of paths to YAML files that define NAME: VALUE pairs. Return a map of the NAME: VALUE pairs. Along the way,
// each VALUE is parsed as YAML.
func ParseVars(varsList []string, varFileList []string) (map[string]any, error) {
	variables := map[string]any{}

	varsFromEnv, err := parseVariablesFromEnvironmentVariables()
	if err != nil {
		return variables, err
	}

	varsFromVarsList, err := parseVariablesFromKeyValuePairs(varsList)
	if err != nil {
		return variables, err
	}

	varsFromVarFiles, err := parseVariablesFromVarFiles(varFileList)
	if err != nil {
		return variables, err
	}

	return util.MergeMaps(varsFromEnv, varsFromVarsList, varsFromVarFiles), nil
}

// convertYAMLToStringMap modifies an input with type map[any]interface{} to map[string]interface{} so that it may be
// properly marshalled in to JSON.
// See: https://github.com/go-yaml/yaml/issues/139
func ConvertYAMLToStringMap(yamlMapOrList any) (interface{}, error) {
	switch mapOrList := yamlMapOrList.(type) {
	case map[any]interface{}:
		outputMap := map[string]any{}
		for k, v := range mapOrList {
			strK, ok := k.(string)
			if !ok {
				return nil, YAMLConversionErr{k}
			}
			res, err := ConvertYAMLToStringMap(v)
			if err != nil {
				return nil, err
			}
			outputMap[strK] = res
		}
		return outputMap, nil
	case []any:
		for index, value := range mapOrList {
			res, err := ConvertYAMLToStringMap(value)
			if err != nil {
				return nil, err
			}
			mapOrList[index] = res
		}
	}
	return yamlMapOrList, nil
}

// Custom error types

type YAMLConversionErr struct {
	Key any
}

func (err YAMLConversionErr) Error() string {
	return fmt.Sprintf("YAML value has type %s and cannot be cast to to the correct type.", reflect.TypeOf(err.Key))
}

type ValidationsMissing string

func (err ValidationsMissing) Error() string {
	return fmt.Sprintf("%s does not specify any validations. You must specify at least one validation.", string(err))
}

type OptionsMissing string

func (err OptionsMissing) Error() string {
	return fmt.Sprintf("%s has type %s but does not specify any options. You must specify at least one option.", string(err), Enum)
}

type InvalidVariableValue struct {
	Value    any
	Variable Variable
}

func (err InvalidVariableValue) Error() string {
	message := fmt.Sprintf("Value '%v' is not a valid value for variable '%s' with type '%s'.", err.Value, err.Variable.Name(), err.Variable.Type().String())
	if err.Variable.Type() == Enum {
		message = fmt.Sprintf("%s. Value must be one of: %s.", message, err.Variable.Options())
	}
	return message
}

type OptionsCanOnlyBeUsedWithEnum struct {
	Context string
	Type    BoilerplateType
}

func (err OptionsCanOnlyBeUsedWithEnum) Error() string {
	return fmt.Sprintf("%s has type %s and tries to specify options. Options may only be specified for the %s type.", err.Context, err.Type.String(), Enum)
}

type InvalidTypeForField struct {
	FieldName    string
	ExpectedType string
	ActualType   reflect.Type
	Context      string
}

func (err InvalidTypeForField) Error() string {
	message := fmt.Sprintf("Field %s in %s must have type %s but got %s", err.FieldName, err.Context, err.ExpectedType, err.ActualType)
	return message
}

type VariableNameCannotBeEmpty string

func (varSyntax VariableNameCannotBeEmpty) Error() string {
	return fmt.Sprintf("Variable name cannot be empty. Expected NAME=VALUE but got %s", string(varSyntax))
}

type InvalidVarSyntax string

func (varSyntax InvalidVarSyntax) Error() string {
	return fmt.Sprintf("Invalid syntax for variable. Expected NAME=VALUE but got %s", string(varSyntax))
}

type RequiredFieldMissing string

func (err RequiredFieldMissing) Error() string {
	return fmt.Sprintf("Required field %s is missing", string(err))
}

type MutexRequiredFieldErr struct {
	fields []string
}

func (err MutexRequiredFieldErr) Error() string {
	return fmt.Sprintf("Exactly one of the following fields must be set: %s", strings.Join(err.fields, ","))
}

type UnrecognizedBoilerplateType BoilerplateType

func (err UnrecognizedBoilerplateType) Error() string {
	return fmt.Sprintf("Unrecognized type: %s", BoilerplateType(err).String())
}

type UndefinedOrderForFieldErr struct {
	fieldName string
}

func (err UndefinedOrderForFieldErr) Error() string {
	return fmt.Sprintf("No order value defined for field: %s", err.fieldName)
}
-- variables/yaml_helpers_test.go --
package variables

import (
	"reflect"
	"testing"

	"gopkg.in/yaml.v2"

	"github.com/google/go-cmp/cmp"
	"github.com/gruntwork-io/boilerplate/errors"
	"github.com/stretchr/testify/assert"
)

const YAML_FILE_ONE_VAR = `
key: value
`

const YAML_FILE_MULTIPLE_VARS = `
key1: value1
key2: value2
key3: value3
`

func TestParseVariablesFromVarFileContents(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		fileContents        string
		expectYamlTypeError bool
		expectedVars        map[string]interface{}
	}{
		{"", false, map[string]interface{}{}},
		{YAML_FILE_ONE_VAR, false, map[string]interface{}{"key": "value"}},
		{YAML_FILE_MULTIPLE_VARS, false, map[string]interface{}{"key1": "value1", "key2": "value2", "key3": "value3"}},
		{"invalid yaml", true, map[string]interface{}{}},
	}

	for _, testCase := range testCases {
		actualVars, err := parseVariablesFromVarFileContents([]byte(testCase.fileContents))
		if testCase.expectYamlTypeError {
			assert.NotNil(t, err)
			unwrapped := errors.Unwrap(err)
			_, isYamlTypeError := unwrapped.(*yaml.TypeError)
			assert.True(t, isYamlTypeError, "Expected a YAML type error for an invalid yaml file but got %s", reflect.TypeOf(unwrapped))
		} else {
			assert.Nil(t, err, "Got unexpected error: %v", err)
			assert.Equal(t, testCase.expectedVars, actualVars)
		}
	}
}

func TestParseVariablesFromKeyValuePairs(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		keyValuePairs []string
		expectedError error
		expectedVars  map[string]interface{}
	}{
		{[]string{}, nil, map[string]interface{}{}},
		{[]string{"key=value"}, nil, map[string]interface{}{"key": "value"}},
		{[]string{"key="}, nil, map[string]interface{}{"key": nil}},
		{[]string{"key1=value1", "key2=value2", "key3=value3"}, nil, map[string]interface{}{"key1": "value1", "key2": "value2", "key3": "value3"}},
		{[]string{"key1=left=right"}, nil, map[string]interface{}{"key1": "left=right"}},
		{[]string{"invalidsyntax"}, InvalidVarSyntax("invalidsyntax"), map[string]interface{}{}},
		{[]string{"="}, VariableNameCannotBeEmpty("="), map[string]interface{}{}},
		{[]string{"=foo"}, VariableNameCannotBeEmpty("=foo"), map[string]interface{}{}},
	}

	for _, testCase := range testCases {
		actualVars, err := parseVariablesFromKeyValuePairs(testCase.keyValuePairs)
		if testCase.expectedError == nil {
			assert.Nil(t, err)
			assert.Equal(t, testCase.expectedVars, actualVars)
		} else {
			assert.NotNil(t, err)
			assert.True(t, errors.IsError(err, testCase.expectedError), "Expected an error of type '%s' with value '%s' but got an error of type '%s' with value '%s'", reflect.TypeOf(testCase.expectedError), testCase.expectedError.Error(), reflect.TypeOf(err), err.Error())
		}
	}
}

func TestConvert(t *testing.T) {
	t.Parallel()

	testCases := []struct {
		input        interface{}
		expectedType interface{}
	}{
		{
			input:        "",
			expectedType: "string",
		},
		{
			input: map[interface{}]interface{}{
				"key1": "value1",
				"key2": "value2",
			},
			expectedType: map[string]interface{}{},
		},
		{
			input: map[string]interface{}{
				"key1": "value1",
			},
			expectedType: map[string]interface{}{},
		},
		{
			input: []interface{}{
				map[interface{}]interface{}{
					"key1": "value1",
				},
				"",
			},
			expectedType: []interface{}{},
		},
		{
			input: map[string]interface{}{
				"key3": 42,
				"key1": map[string]interface{}{
					"key2": "value2",
				},
			},
			expectedType: map[string]interface{}{},
		},
	}

	for _, testCase := range testCases {
		actual, err := ConvertYAMLToStringMap(testCase.input)
		assert.NoError(t, err)
		assert.IsType(t, testCase.expectedType, actual)
	}
}

func TestParserulestring(t *testing.T) {
	t.Parallel()

	type TestCase struct {
		Input string
		Want  []string
	}

	testCases := []TestCase{
		{
			Input: "[required length-5-22 alphanumeric]",
			Want:  []string{"required", "length-5-22", "alphanumeric"},
		},
		{
			Input: "[required]",
			Want:  []string{"required"},
		},
		{
			Input: "[alphanumeric length-10-30]",
			Want:  []string{"alphanumeric", "length-10-30"},
		},
		{
			Input: "[length-1-3 required url email alpha digit alphanumeric CountryCode2]",
			Want:  []string{"length-1-3", "required", "url", "email", "alpha", "digit", "alphanumeric", "countrycode2"},
		},
		{
			Input: "[LENGTH-1-3 REQUIRED URL EMAIL ALPHA DIGIT ALPHANUMERIC COUNTRYCODE2]",
			Want:  []string{"length-1-3", "required", "url", "email", "alpha", "digit", "alphanumeric", "countrycode2"},
		},
	}

	for _, tc := range testCases {
		got := parseRuleString(tc.Input)
		if !cmp.Equal(got, tc.Want) {
			t.Logf("Got %v for input %s but wanted %v\n", got, tc.Input, tc.Want)
			t.Fail()
		}
	}
}
{{end}}